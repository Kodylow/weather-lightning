{"version":3,"file":"index.modern.js","sources":["../src/utils/storage.ts","../src/l402/parse.js","../src/l402/index.ts","../src/podcasting2/boostagrams.ts","../src/utils/keysend.ts","../src/utils/lnurl.ts","../src/invoice.ts","../src/utils/invoice.ts","../src/utils/nostr.ts","../src/lightning-address.ts","../src/utils/fiat.ts"],"sourcesContent":["export class MemoryStorage {\n  storage;\n\n  constructor(initial?: any) {\n    this.storage = initial || {};\n  }\n\n  getItem(key) {\n    return this.storage[key];\n  }\n\n  setItem(key, value) {\n    this.storage[key] = value;\n  }\n}\n\nexport class NoStorage {\n  constructor(initial?: any) {\n  }\n\n  getItem(key) {\n    return null;\n  }\n\n  setItem(key, value) {\n  }\n}\n\nexport default MemoryStorage;\n","export const parseL402 = (string) => {\n  string = string.replace('L402', '');\n  string = string.replace('LSAT', '');\n  // Split the string into key-value pairs\n  const pairs = string.split(',');\n\n  // Split each pair into key and value\n  const keyValuePairArray = pairs.map(pair => {\n    const [key, valuePotentiallyQuoted] = pair.split('=').map(e => e.trim());\n    const valueMatch = valuePotentiallyQuoted.match(/\"?([^\"]*)\"?/);\n    const value = valueMatch[1]\n    return [key, value];\n  });\n\n  return Object.fromEntries(keyValuePairArray);\n}\n","import MemoryStorage from \"../utils/storage\";\nimport { WebLNProvider } from '@webbtc/webln-types';\nimport { parseL402 } from \"./parse\";\n\nexport * as storage from \"../utils/storage\";\nconst memoryStorage = new MemoryStorage();\n\nconst HEADER_KEY = \"L402\"; // we have to update this to L402 at some point\n\nexport const fetchWithL402 = async (url: string, fetchArgs: Record<string, any>, options: Record<string, any>) => {\n  if (!options) {\n    options = {};\n  }\n  const headerKey = options.headerKey || HEADER_KEY;\n  const webln: WebLNProvider = options.webln || globalThis.webln;\n  if (!webln) {\n    throw new Error(\"WebLN is missing\");\n  }\n  let store = options.store || memoryStorage;\n  if (!fetchArgs) {\n    fetchArgs = {};\n  }\n  fetchArgs.cache = 'no-store';\n  fetchArgs.mode = 'cors';\n  if (!fetchArgs.headers) {\n    fetchArgs.headers = {};\n  }\n  const cachedL402Data = store.getItem(url);\n  if (cachedL402Data) {\n    const data = JSON.parse(cachedL402Data);\n    fetchArgs.headers[\"Authorization\"] = `${headerKey} ${data.token}:${data.preimage}`;\n    return await fetch(url, fetchArgs)\n  }\n\n  fetchArgs.headers[\"Accept-Authenticate\"] = headerKey;\n  const initResp = await fetch(url, fetchArgs);\n  const header = initResp.headers.get('www-authenticate');\n  if (!header) {\n    return initResp\n  }\n\n  const details = parseL402(header);\n  const token = details.token || details.macaroon;\n  const inv = details.invoice;\n\n  await webln.enable();\n  const invResp = await webln.sendPayment(inv);\n\n  store.setItem(url, JSON.stringify({\n    'token': token,\n    'preimage': invResp.preimage\n  }));\n\n  fetchArgs.headers[\"Authorization\"] = `${headerKey} ${token}:${invResp.preimage}`;\n  return await fetch(url, fetchArgs);\n}\n\nexport default fetchWithL402;\n","import { WebLNProvider } from \"@webbtc/webln-types\";\n\ntype BoostOptions = {\n  webln?: unknown;\n}\n\ntype BoostArguments = {\n  destination: string\n  customKey?: string;\n  customValue?: string;\n  amount?: number;\n  boost: Boost;\n}\n\ntype WeblnBoostParams = {\n  destination: string;\n  amount: number;\n  customRecords: Record<string, string>;\n}\n\nexport type Boost = {\n  action: string;\n  value_msat: number;\n  value_msat_total: number;\n  app_name: string;\n  app_version: string;\n  feedId: string;\n  podcast: string;\n  episode: string;\n  ts: number;\n  name: string;\n  sender_name: string;\n}\n\nexport const boost = async (args: BoostArguments, options?: BoostOptions) => {\n  let { boost, amount } = args;\n  if (!options) {\n    options = {};\n  }\n  const webln: WebLNProvider = options.webln || globalThis.webln;\n  if (!amount) {\n    amount = Math.floor(boost.value_msat / 1000);\n  }\n\n  let weblnParams: WeblnBoostParams = {\n    destination: args.destination,\n    amount: amount,\n    customRecords: {\n      '7629169': JSON.stringify(boost)\n    }\n  };\n  if (args.customKey && args.customValue) {\n    weblnParams.customRecords[args.customKey] = args.customValue;\n  }\n  await webln.enable();\n  const response = await webln.keysend(weblnParams);\n  return response;\n}\n\nexport default boost;\n","import type { KeysendResponse } from '../types'\n\nconst TAG_KEYSEND = 'keysend'\n\nexport const parseKeysendResponse = (\n  data: Record<string, any>\n): KeysendResponse => {\n  if (data.tag !== TAG_KEYSEND) throw new Error('Invalid keysend params')\n  if (data.status !== \"OK\") throw new Error('Keysend status not OK')\n\n  if (!('customKey' in data.customData[0]) || data.customData[0]['customKey'] != '696969')\n    throw new Error('Unable to find customKey');\n\n  if (!('customValue' in data.customData[0]) || !data.customData[0]['customValue'])\n    throw new Error('Unable to find customValue');\n\n  if (!data.pubkey)\n    throw new Error('Pubkey does not exist');\n\n  const destination =  data.pubkey;\n  const customKey = data.customData[0]['customKey'];\n  const customValue = data.customData[0]['customValue'];\n  \n  return {\n    destination,\n    customKey,\n    customValue\n  }\n}","import Hex from \"crypto-js/enc-hex.js\";\nimport sha256 from \"crypto-js/sha256.js\";\n\nimport type { LUD18ServicePayerData, LnUrlPayResponse } from '../types'\n\nconst URL_REGEX = /((([A-Za-z]{3,9}:(?:\\/\\/)?)(?:[-;:&=\\+\\$,\\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=\\+\\$,\\w]+@)[A-Za-z0-9.-]+)((?:\\/[\\+~%\\/.\\w-_]*)?\\??(?:[-\\+=&;%@.\\w_]*)#?(?:[\\w]*))?)/;\n\nexport const isUrl = (url: string | null): url is string => {\n  if (!url) return false\n  return URL_REGEX.test(url)\n}\n\nexport const isValidAmount = ({\n  amount,\n  min,\n  max,\n}: {\n  amount: number\n  min: number\n  max: number\n}): boolean => {\n  const isValid = amount > 0 && amount >= min && amount <= max\n  const isFixed = min === max\n  return isValid && isFixed ? amount === min : isValid\n}\n\nconst TAG_PAY_REQUEST = 'payRequest'\n\n// From: https://github.com/dolcalmi/lnurl-pay/blob/main/src/request-pay-service-params.ts\nexport const parseLnUrlPayResponse = (\n  data: Record<string, any>\n): LnUrlPayResponse => {\n  if (data.tag !== TAG_PAY_REQUEST) throw new Error('Invalid pay service params')\n\n  const callback = (data.callback + '').trim();\n  if (!isUrl(callback)) throw new Error('Callback must be a valid url')\n\n  const min = Math.ceil(Number(data.minSendable || 0))\n  const max = Math.floor(Number(data.maxSendable))\n  if (!(min && max) || min > max) throw new Error('Invalid pay service params')\n\n  let metadata: Array<Array<string>>\n  let metadataHash: string\n  try {\n    metadata = JSON.parse(data.metadata + '')\n    metadataHash = sha256(data.metadata + '').toString(Hex)\n  } catch {\n    metadata = []\n    metadataHash = sha256('[]').toString(Hex)\n  }\n\n  let image = ''\n  let description = ''\n  let identifier = ''\n  for (let i = 0; i < metadata.length; i++) {\n    const [k, v] = metadata[i]\n    switch (k) {\n      case 'text/plain':\n        description = v\n        break\n      case 'text/identifier':\n        identifier = v\n        break\n      case 'image/png;base64':\n      case 'image/jpeg;base64':\n        image = 'data:' + k + ',' + v\n        break\n    }\n  }\n  let payerData = data.payerData as LUD18ServicePayerData | undefined;\n\n  let domain\n  try {\n    domain = new URL(callback).hostname\n  } catch {\n    // fail silently and let domain remain undefined if callback is not a valid URL\n  }\n\n  return {\n    callback,\n    fixed: min === max,\n    min,\n    max,\n    domain,\n    metadata,\n    metadataHash,\n    identifier,\n    description,\n    image,\n    payerData,\n    commentAllowed: Number(data.commentAllowed) || 0,\n    rawData: data,\n    allowsNostr: data.allowsNostr || false,\n  }\n}\n","import { getHashFromInvoice } from \"./utils/invoice\";\nimport Hex from \"crypto-js/enc-hex.js\";\nimport sha256 from \"crypto-js/sha256.js\";\nimport { InvoiceArgs } from './types';\n\nexport default class Invoice {\n  paymentRequest: string;\n  paymentHash: string;\n  preimage: string | null;\n  verify: string | null;\n\n  constructor(args: InvoiceArgs) {\n    this.paymentRequest = args.pr;\n    this.paymentHash = getHashFromInvoice(this.paymentRequest) as string;\n    this.verify = args.verify ?? null;\n    this.preimage = args.preimage ?? null;\n  }\n\n  async isPaid(): Promise<boolean> {\n    if (this.preimage)\n      return this.validatePreimage(this.preimage);\n    else if (this.verify) {\n      return await this.verifyPayment();\n    } else {\n      throw new Error('Could not verify payment');\n    }\n  }\n\n  validatePreimage(preimage: string): boolean {\n    if (!preimage || !this.paymentHash) return false\n  \n    try {\n      const preimageHash = sha256(Hex.parse(preimage)).toString(Hex)\n      return this.paymentHash === preimageHash\n    } catch {\n      return false\n    }\n  }\n\n  async verifyPayment(): Promise<boolean> {\n    if (!this.verify) throw new Error('LNURL verify not available');\n    const result = await fetch(this.verify);\n    const json = await result.json();\n    if (json.preimage) {\n      this.preimage = json.preimage;\n    }\n  \n    return json.settled;\n  }\n}","import { decode } from 'light-bolt11-decoder';\n\nexport const getHashFromInvoice = (invoice) => {\n  if (!invoice) return null\n\n  try {\n    const decoded = decode(invoice)\n    if (!decoded || !decoded.sections) return null\n\n    const hashTag = decoded.sections.find(\n      (value) => value.name === 'payment_hash'\n    )\n    if (!hashTag || !hashTag.value) return null\n\n    return hashTag.value.toString()\n  } catch {\n    return null\n  }\n}","import Hex from \"crypto-js/enc-hex.js\";\nimport sha256 from \"crypto-js/sha256.js\";\nimport { Event, NostrResponse, ZapArgs, ZapOptions } from '../types';\n\nexport async function generateZapEvent({\n  satoshi, comment, p, e, relays\n}: ZapArgs, options: ZapOptions = {}): Promise<Event> {\n  const nostr = options.nostr || globalThis.nostr;\n  if (!nostr) {\n    throw new Error(\"nostr option or window.nostr is not available\");\n  }\n\n  const nostrTags = [\n    [\"relays\", ...relays],\n    [\"amount\", satoshi.toString()]\n  ]\n  if (p) {\n    nostrTags.push([\"p\", p]);\n  }\n  if (e) {\n    nostrTags.push([\"e\", e])\n  }\n\n  const pubkey = await nostr.getPublicKey();\n\n  const nostrEvent: Event = {\n    pubkey,\n    created_at: Math.floor(Date.now() / 1000),\n    kind: 9734,\n    tags: nostrTags,\n    content: comment ?? \"\"\n  }\n\n  nostrEvent.id = getEventHash(nostrEvent)\n  return await nostr.signEvent(nostrEvent)\n}\n\nexport function validateEvent(event: Event): boolean {\n  if (typeof event.content !== \"string\") return false;\n  if (typeof event.created_at !== \"number\") return false;\n  // ignore these checks because if the pubkey is not set we add it to the event. same for the ID.\n  // if (typeof event.pubkey !== \"string\") return false;\n  // if (!event.pubkey.match(/^[a-f0-9]{64}$/)) return false;\n\n  if (!Array.isArray(event.tags)) return false;\n  for (let i = 0; i < event.tags.length; i++) {\n    const tag = event.tags[i];\n    if (!Array.isArray(tag)) return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\") return false;\n    }\n  }\n\n  return true;\n}\n\nexport function serializeEvent(evt: Event): string {\n  if (!validateEvent(evt))\n    throw new Error(\"can't serialize event with wrong or missing properties\");\n\n  return JSON.stringify([\n    0,\n    evt.pubkey,\n    evt.created_at,\n    evt.kind,\n    evt.tags,\n    evt.content,\n  ]);\n}\n\nexport function getEventHash(event: Event): string {\n  return sha256(serializeEvent(event)).toString(Hex);\n}\n\nexport function parseNostrResponse(nostrData: NostrResponse, username: string | undefined) {\n  let nostrPubkey: string | undefined;\n  let nostrRelays: string[] | undefined;\n  if (username && nostrData) {\n    nostrPubkey = nostrData.names?.[username];\n    nostrRelays = nostrPubkey ? nostrData.relays?.[nostrPubkey] : undefined;\n  }\n\n  return [nostrData, nostrPubkey, nostrRelays] as const;\n}","import { parseKeysendResponse } from './utils/keysend';\nimport { isUrl, isValidAmount, parseLnUrlPayResponse } from './utils/lnurl';\nimport Invoice from './invoice';\nimport { InvoiceArgs, LnUrlPayResponse, NostrResponse, RequestInvoiceArgs, ZapArgs, ZapOptions } from './types';\nimport { generateZapEvent, parseNostrResponse } from './utils/nostr';\nimport type { Boost } from './podcasting2/boostagrams';\nimport { boost as booster } from './podcasting2/boostagrams';\nimport { WebLNProvider, SendPaymentResponse } from \"@webbtc/webln-types\";\nimport { KeysendResponse } from './types';\n\nconst LN_ADDRESS_REGEX =\n  /^((?:[^<>()\\[\\]\\\\.,;:\\s@\"]+(?:\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(?:\".+\"))@((?:\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(?:(?:[a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\n\nexport const DEFAULT_PROXY = \"https://lnaddressproxy.getalby.com\";\n\ntype LightningAddressOptions = {\n  proxy?: string | false;\n  webln?: WebLNProvider;\n}\n\nexport default class LightningAddress {\n  address: string;\n  options: LightningAddressOptions;\n  username: string | undefined;\n  domain: string | undefined;\n  pubkey: string | undefined;\n  lnurlpData: LnUrlPayResponse | undefined;\n  keysendData: KeysendResponse | undefined;\n  nostrData: NostrResponse | undefined;\n  nostrPubkey: string | undefined;\n  nostrRelays: string[] | undefined;\n  webln: WebLNProvider | undefined;\n\n  constructor(address: string, options?: LightningAddressOptions) {\n    this.address = address;\n    this.options = { proxy: DEFAULT_PROXY, webln: globalThis.webln };\n    this.options = Object.assign(this.options, options);\n    this.parse();\n    this.webln = this.options.webln;\n  }\n\n  parse() {\n    const result = LN_ADDRESS_REGEX.exec(this.address.toLowerCase());\n    if (result) {\n      this.username = result[1];\n      this.domain = result[2];\n    }\n  }\n\n  async fetch() {\n    if (this.options.proxy) {\n      return this.fetchWithProxy();\n    } else {\n      return this.fetchWithoutProxy();\n    }\n  }\n\n  async fetchWithProxy() {\n    const result = await fetch(`${this.options.proxy}/lightning-address-details?${new URLSearchParams({ ln: this.address }).toString()}`);\n    const json = await result.json();\n\n    this.parseResponse(json.lnurlp, json.keysend, json.nostr);\n  }\n\n  async fetchWithoutProxy() {\n    if (!this.domain || !this.username) {\n      return;\n    }\n    const lnurlResult = await fetch(this.lnurlpUrl());\n    const keysendResult = await fetch(this.keysendUrl());\n    const nostrResult = await fetch(this.nostrUrl());\n\n    let lnurlData: Record<string, string> | undefined;\n    if (lnurlResult.ok) {\n      lnurlData = await lnurlResult.json();\n    } \n    let keysendData: Record<string, string> | undefined;\n    if (keysendResult.ok) {\n      keysendData = await keysendResult.json();\n    } \n    let nostrData: NostrResponse | undefined;\n    if (nostrResult.ok) {\n      nostrData = await nostrResult.json();\n    } \n    \n    this.parseResponse(lnurlData, keysendData, nostrData);\n  }\n\n  lnurlpUrl() {\n    return `https://${this.domain}/.well-known/lnurlp/${this.username}`;\n  }\n\n  keysendUrl() {\n    return `https://${this.domain}/.well-known/keysend/${this.username}`;\n  }\n\n  nostrUrl() {\n    return `https://${this.domain}/.well-known/nostr.json?name=${this.username}`;\n  }\n\n  async generateInvoice(params: Record<string, string>): Promise<Invoice> {\n    let data;\n    if (this.options.proxy) {\n      const invoiceResult = await fetch(`${this.options.proxy}/generate-invoice?${new URLSearchParams({ ln: this.address, ...params }).toString()}`);\n      const json = await invoiceResult.json();\n      data = json.invoice;\n    } else {\n      if (!this.lnurlpData) {\n        throw new Error(\"No lnurlpData available. Please call fetch() first.\")\n      }\n      if (!this.lnurlpData.callback || !isUrl(this.lnurlpData.callback)) throw new Error('Valid callback does not exist in lnurlpData')\n      const callbackUrl = new URL(this.lnurlpData.callback)\n      callbackUrl.search = new URLSearchParams(params).toString()\n      const invoiceResult = await fetch(callbackUrl);\n      data = await invoiceResult.json();\n    }\n\n    const paymentRequest = data && data.pr && data.pr.toString();\n    if (!paymentRequest) throw new Error('Invalid pay service invoice')\n\n    const invoiceArgs: InvoiceArgs = { pr: paymentRequest };\n    if (data && data.verify) invoiceArgs.verify = data.verify.toString();\n\n    return new Invoice(invoiceArgs);\n  }\n\n  async requestInvoice(args: RequestInvoiceArgs): Promise<Invoice> {\n    if (!this.lnurlpData) {\n      throw new Error(\"No lnurlpData available. Please call fetch() first.\")\n    }\n    const msat = args.satoshi * 1000;\n    const { commentAllowed, min, max } = this.lnurlpData;\n\n    if (!isValidAmount({ amount: msat, min, max }))\n      throw new Error('Invalid amount')\n    if (args.comment && commentAllowed && commentAllowed > 0 && args.comment.length > commentAllowed)\n      throw new Error(\n        `The comment length must be ${commentAllowed} characters or fewer`\n      )\n\n    const invoiceParams: { amount: string, comment?: string, payerdata?: string } = { amount: msat.toString() };\n    if (args.comment) invoiceParams.comment = args.comment\n    if (args.payerdata) invoiceParams.payerdata = JSON.stringify(args.payerdata)\n\n    return this.generateInvoice(invoiceParams);\n  }\n\n  async boost(boost: Boost, amount: number = 0) {\n    if (!this.keysendData) {\n      throw new Error(\"No keysendData available. Please call fetch() first.\")\n    }\n    const { destination, customKey, customValue } = this.keysendData;\n    return booster({\n      destination,\n      customKey,\n      customValue,\n      amount,\n      boost,\n    }, {\n      webln: this.webln,\n    })\n  }\n\n  async zapInvoice({\n    satoshi, comment, relays, e\n  }: ZapArgs, options: ZapOptions = {}): Promise<Invoice> {\n    if (!this.lnurlpData) {\n      throw new Error(\"No lnurlpData available. Please call fetch() first.\")\n    }\n    if (!this.nostrPubkey) {\n      throw new Error(\"Nostr Pubkey is missing\");\n    }\n    const p = this.nostrPubkey;\n    const msat = satoshi * 1000;\n    const { allowsNostr, min, max } = this.lnurlpData;\n\n    if (!isValidAmount({ amount: msat, min, max }))\n      throw new Error('Invalid amount')\n    if (!allowsNostr) throw new Error('Your provider does not support zaps')\n\n    const event = await generateZapEvent({\n      satoshi: msat, comment, p, e, relays\n    }, options);\n    const zapParams: { amount: string, nostr: string } = {\n      amount: msat.toString(),\n      nostr: JSON.stringify(event)\n    };\n\n    const invoice = await this.generateInvoice(zapParams);\n    return invoice;\n  }\n\n  async zap(args: ZapArgs, options: ZapOptions = {}): Promise<SendPaymentResponse> {\n    const invoice = this.zapInvoice(args, options);\n    if (!this.webln) {\n      // mainly for TS\n      throw new Error(\"WebLN not available\");\n    }\n    await this.webln.enable();\n    const response = this.webln.sendPayment((await invoice).paymentRequest);\n    return response;\n  }\n\n  private parseResponse(lnurlpData: Record<string, string> | undefined, keysendData: Record<string, string> | undefined, nostrData: NostrResponse | undefined) {\n    if (lnurlpData) {\n      this.lnurlpData = parseLnUrlPayResponse(lnurlpData);\n    }\n    if (keysendData) {\n      this.keysendData = parseKeysendResponse(keysendData);\n    }\n    if (nostrData) {\n      [this.nostrData, this.nostrPubkey, this.nostrRelays] = parseNostrResponse(nostrData, this.username);\n    }\n  }\n}\n","const numSatsInBtc = 100_000_000;\n\nexport const getFiatBtcRate = async (currency: string): Promise<number> => {\n  const url = \"https://getalby.com/api/rates/\" + currency.toLowerCase() + \".json\";\n  const response = await fetch(url);\n  const data = await response.json();\n\n  return data.rate_float / numSatsInBtc;\n};\n\nexport const getFiatValue = async ({ satoshi, currency }: { satoshi: number | string; currency: string; }) => {\n  const rate = await getFiatBtcRate(currency);\n\n  return Number(satoshi) * rate;\n};\n\nexport const getSatoshiValue = async ({ amount, currency }: { amount: number | string; currency: string; }) => {\n  const rate = await getFiatBtcRate(currency);\n\n  return Math.floor(Number(amount) / rate);\n}\n\nexport const getFormattedFiatValue = async ({ satoshi, currency, locale }: { satoshi: number | string; currency: string; locale: string }) => {\n  if (!locale) {\n    locale = 'en';\n  }\n  const fiatValue = await getFiatValue({ satoshi, currency });\n  return fiatValue.toLocaleString(locale, {\n    style: \"currency\",\n    currency,\n  });\n}"],"names":["MemoryStorage","constructor","initial","this","storage","getItem","key","setItem","value","memoryStorage","fetchWithL402","async","url","fetchArgs","options","headerKey","webln","globalThis","Error","store","cache","mode","headers","cachedL402Data","data","JSON","parse","token","preimage","fetch","header","initResp","get","details","string","replace","split","map","pair","valuePotentiallyQuoted","e","trim","match","Object","fromEntries","keyValuePairArray","parseL402","macaroon","inv","invoice","enable","invResp","sendPayment","stringify","boost","args","amount","Math","floor","value_msat","weblnParams","destination","customRecords","customKey","customValue","keysend","response","test","isValidAmount","min","max","isValid","Invoice","_args$verify","_args$preimage","paymentRequest","paymentHash","verify","pr","decode","decoded","sections","hashTag","find","name","toString","_unused","getHashFromInvoice","validatePreimage","verifyPayment","preimageHash","sha256","Hex","result","json","settled","generateZapEvent","satoshi","comment","p","relays","nostr","nostrTags","push","nostrEvent","pubkey","getPublicKey","created_at","Date","now","kind","tags","content","id","getEventHash","signEvent","event","Array","isArray","i","length","tag","j","serializeEvent","evt","validateEvent","nostrData","username","nostrPubkey","nostrRelays","_nostrData$names","_nostrData$relays","names","undefined","LN_ADDRESS_REGEX","LightningAddress","address","domain","lnurlpData","keysendData","proxy","assign","exec","toLowerCase","fetchWithProxy","fetchWithoutProxy","URLSearchParams","ln","parseResponse","lnurlp","lnurlpUrl","keysendResult","keysendUrl","nostrResult","nostrUrl","lnurlData","lnurlResult","ok","params","invoiceResult","callback","isUrl","callbackUrl","URL","search","invoiceArgs","commentAllowed","msat","invoiceParams","payerdata","generateInvoice","booster","allowsNostr","zapParams","zapInvoice","ceil","Number","minSendable","maxSendable","metadata","metadataHash","image","description","identifier","k","v","payerData","hostname","_unused2","fixed","rawData","parseLnUrlPayResponse","status","customData","parseKeysendResponse","parseNostrResponse","getFiatBtcRate","currency","rate_float","numSatsInBtc","rate","locale","getFiatValue","toLocaleString","style"],"mappings":"2HAA0BA,EAGxBC,YAAYC,GAAaC,KAFzBC,aAAO,EAGLD,KAAKC,QAAUF,GAAW,CAC5B,CAAA,CAEAG,QAAQC,GACN,YAAYF,QAAQE,EACtB,CAEAC,QAAQD,EAAKE,GACXL,KAAKC,QAAQE,GAAOE,CACtB,wDAIAP,YAAYC,GAGZG,CAAAA,QAAQC,GACN,WACF,CAEAC,QAAQD,EAAKE,GAEd,cC1BM,MCKYC,EAAG,IAAIT,EAIAU,EAAGC,MAAOC,EAAaC,EAAgCC,KAC1EA,IACHA,EAAU,IAEZ,QAAkBA,EAAQC,WANT,OAOXC,EAAuBF,EAAQE,OAASC,WAAWD,MACzD,IAAKA,EACH,UAAeE,MAAC,oBAElB,IAASC,EAAGL,EAAQK,OAASV,EACxBI,IACHA,EAAY,CACb,GACDA,EAAUO,MAAQ,WAClBP,EAAUQ,KAAO,OACZR,EAAUS,UACbT,EAAUS,QAAU,CAAA,GAEtB,MAAoBC,EAAGJ,EAAMd,QAAQO,GACrC,GAAIW,EAAgB,CAClB,MAAMC,EAAOC,KAAKC,MAAMH,GAExB,OADAV,EAAUS,QAAuB,cAAO,GAAAP,KAAaS,EAAKG,SAASH,EAAKI,iBACtDC,MAACjB,EAAKC,EACzB,CAEDA,EAAUS,QAAQ,uBAAyBP,EAC3C,cAA4Bc,MAACjB,EAAKC,GACtBiB,EAAGC,EAAST,QAAQU,IAAI,oBACpC,IAAKF,EACH,OACDC,EAED,MAAaE,EDzCWC,KAIxB,SAFAA,GADAA,EAASA,EAAOC,QAAQ,OAAQ,KAChBA,QAAQ,OAAQ,KAEXC,MAAM,KAGKC,IAAIC,IAClC,MAAOhC,EAAKiC,GAA0BD,EAAKF,MAAM,KAAKC,IAAIG,GAAKA,EAAEC,QAGjE,MAAO,CAACnC,EAFWiC,EAAuBG,MAAM,eACvB,GACP,GAGpB,OAAOC,OAAOC,YAAYC,EAAiB,EC2B3BC,CAAUhB,GACpBH,EAAQM,EAAQN,OAASM,EAAQc,SAC9BC,EAAGf,EAAQgB,cAETjC,EAACkC,SACZ,MAAMC,QAAgBnC,EAAMoC,YAAYJ,GAQxC,OANA7B,EAAMZ,QAAQK,EAAKa,KAAK4B,UAAU,CAChC1B,MAASA,EACTC,SAAYuB,EAAQvB,YAGtBf,EAAUS,QAAuB,cAAI,GAAGP,KAAaY,KAASwB,EAAQvB,iBACzDC,MAAMjB,EAAKC,EAAS,6DCpBtByC,MAAAA,EAAQ3C,MAAO4C,EAAsBzC,KAChD,IAAIwC,MAAEA,EAAKE,OAAEA,GAAWD,EACnBzC,IACHA,EAAU,CACX,GACD,MAAWE,EAAkBF,EAAQE,OAASC,WAAWD,MACpDwC,IACHA,EAASC,KAAKC,MAAMJ,EAAMK,WAAa,MAGzC,IAAeC,EAAqB,CAClCC,YAAaN,EAAKM,YAClBL,OAAQA,EACRM,cAAe,CACb,QAAWrC,KAAK4B,UAAUC,KAQ9B,OALIC,EAAKQ,WAAaR,EAAKS,cACzBJ,EAAYE,cAAcP,EAAKQ,WAAaR,EAAKS,mBAE7ChD,EAAMkC,eACWlC,EAAMiD,QAAQL,EAC9BM,+QCtDT,QCGkB,sKAEItD,KACfA,KACYuD,KAAKvD,GAGEwD,EAAG,EAC3BZ,SACAa,MACAC,UAMA,MAAaC,EAAGf,EAAS,GAAKA,GAAUa,GAAOb,GAAUc,EAEzD,OAAcC,GADEF,IAAQC,EACId,IAAWa,EAAME,GClBjC,MAAcC,EAM1BvE,YAAYsD,GAAiB,IAAAkB,EAAAC,EAAAvE,KAL7BwE,oBAAc,EAAAxE,KACdyE,iBACAhD,EAAAA,KAAAA,cACAiD,EAAAA,KAAAA,YAGE,EAAA1E,KAAKwE,eAAiBpB,EAAKuB,GAC3B3E,KAAKyE,YCX0B3B,KACjC,IAAKA,EAAS,YAEd,IACE,QAAgB8B,EAAO9B,GACvB,IAAK+B,IAAYA,EAAQC,SAAU,YAEnC,MAAaC,EAAGF,EAAQC,SAASE,KAC9B3E,GAAyB,iBAAfA,EAAM4E,MAEnB,OAAKF,GAAYA,EAAQ1E,QAEVA,MAAM6E,eAGtB,CAFC,MAAAC,GACA,OAAO,IACR,GDJoBC,CAAmBpF,KAAKwE,gBAC3CxE,KAAK0E,OAAoB,SAAXtB,EAAKsB,QAAMJ,EAAI,KAC7BtE,KAAKyB,gBAAW2B,EAAAA,EAAK3B,YAAY,IACnC,CAEAjB,eACE,GAAIR,KAAKyB,SACP,OAAOzB,KAAKqF,iBAAiBrF,KAAKyB,UAC/B,GAAIzB,KAAK0E,OACZ,aAAiB1E,KAACsF,gBAElB,MAAM,IAASvE,MAAC,2BAEpB,CAEAsE,iBAAiB5D,GACf,IAAKA,IAAazB,KAAKyE,YAAa,OAAO,EAE3C,IACE,MAAMc,EAAeC,EAAOC,EAAIlE,MAAME,IAAWyD,SAASO,GAC1D,OAAWzF,KAACyE,cAAgBc,CAG7B,CAFC,SACA,OACD,CAAA,CACH,CAEA/E,sBACE,IAAKR,KAAK0E,OAAQ,MAAU3D,IAAAA,MAAM,8BAClC,MAAY2E,QAAShE,MAAM1B,KAAK0E,gBACPgB,EAACC,OAK1B,OAJIA,EAAKlE,WACPzB,KAAKyB,SAAWkE,EAAKlE,UAGhBkE,EAAKC,OACd,iBE5CoCC,GAACC,QACrCA,EAAOC,QAAEA,EAAOC,EAAEA,EAAC3D,EAAEA,EAAC4D,OAAEA,GACdtF,EAAsB,CAAA,GAChC,MAAWuF,EAAGvF,EAAQuF,OAASpF,WAAWoF,MAC1C,IAAKA,EACH,MAAM,UAAU,iDAGlB,QAAkB,CAChB,CAAC,YAAaD,GACd,CAAC,SAAUH,EAAQZ,aAEjBc,GACFG,EAAUC,KAAK,CAAC,IAAKJ,IAEnB3D,GACF8D,EAAUC,KAAK,CAAC,IAAK/D,IAGvB,MAEMgE,EAAoB,CACxBC,aAHmBJ,EAAMK,eAIzBC,WAAYlD,KAAKC,MAAMkD,KAAKC,MAAQ,KACpCC,KAAM,KACNC,KAAMT,EACNU,cAASd,EAAAA,EAAW,IAItB,OADAM,EAAWS,GAAKC,EAAaV,SAChBH,EAAMc,UAAUX,EAC/B,CAEM,WAAwBY,GAC5B,GAA6B,mBAAZJ,QAAsB,OAAY,EACnD,GAAgC,iBAAhBI,EAACT,WAAyB,OAAO,EAKjD,IAAKU,MAAMC,QAAQF,EAAML,MAAO,SAChC,IAAK,IAAKQ,EAAG,EAAGA,EAAIH,EAAML,KAAKS,OAAQD,IAAK,CAC1C,MAAME,EAAML,EAAML,KAAKQ,GACvB,IAAKF,MAAMC,QAAQG,GAAM,OAAO,EAChC,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAID,OAAQE,IAC9B,GAAsB,iBAAXD,EAAIC,GAAiB,OAAO,CAE1C,CAED,OACF,CAAA,CAEgBC,SAAAA,EAAeC,GAC7B,IAAKC,EAAcD,GACjB,MAAM,UAAU,0DAElB,OAAOnG,KAAK4B,UAAU,CACpB,EACAuE,EAAInB,OACJmB,EAAIjB,WACJiB,EAAId,KACJc,EAAIb,KACJa,EAAIZ,SAER,CAEgBE,SAAAA,EAAaE,GAC3B,OAAazB,EAACgC,EAAeP,IAAQ/B,SAASO,EAChD,CAEgB,WAAmBkC,EAA0BC,GAC3D,IAAIC,EACiCC,EACV,IAAAC,EAAAC,EAK3B,OALIJ,GAAYD,IACdE,EAAc,OAAAF,EAAAA,EAAUM,YAAV,EAAAF,EAAkBH,GAChCE,EAAcD,EAA8B,SAAhBF,EAAU1B,aAAM,EAAhB+B,EAAmBH,QAAeK,GAGzD,CAACP,EAAWE,EAAaC,EAClC,gHCzEA,MAAsBK,EACpB,sKASY,MAAuBC,EAanCtI,YAAYuI,EAAiB1H,GAAiCX,KAZ9DqI,aAAO,EAAArI,KACPW,aACAiH,EAAAA,KAAAA,cACAU,EAAAA,KAAAA,YACAhC,EAAAA,KAAAA,YACAiC,EAAAA,KAAAA,uBACAC,iBAAW,EAAAxI,KACX2H,eAAS,EAAA3H,KACT6H,iBAAW,EAAA7H,KACX8H,iBAAW,EAAA9H,KACXa,WAAK,EAGHb,KAAKqI,QAAUA,EACfrI,KAAKW,QAAU,CAAE8H,MAtBQ,qCAsBc5H,MAAOC,WAAWD,OACzDb,KAAKW,QAAU6B,OAAOkG,OAAO1I,KAAKW,QAASA,GAC3CX,KAAKuB,QACLvB,KAAKa,MAAQb,KAAKW,QAAQE,KAC5B,CAEAU,QACE,MAAMmE,EAASyC,EAAiBQ,KAAK3I,KAAKqI,QAAQO,eAC9ClD,IACF1F,KAAK4H,SAAWlC,EAAO,GACvB1F,KAAKsI,OAAS5C,EAAO,GAEzB,CAEAlF,cACE,OAAIR,KAAKW,QAAQ8H,MACRzI,KAAK6I,iBAED7I,KAAC8I,mBAEhB,CAEAtI,uBACE,MAAYkF,QAAShE,MAAM,GAAG1B,KAAKW,QAAQ8H,mCAAmC,IAAmBM,gBAAC,CAAEC,GAAIhJ,KAAKqI,UAAWnD,sBAC/FQ,EAACC,OAE1B3F,KAAKiJ,cAActD,EAAKuD,OAAQvD,EAAK7B,QAAS6B,EAAKO,MACrD,CAEA1F,0BACE,IAAKR,KAAKsI,SAAWtI,KAAK4H,SACxB,OAEF,cAA+BlG,MAAC1B,KAAKmJ,aAC/BC,QAA2B1H,MAAC1B,KAAKqJ,cACtBC,QAAc5H,MAAC1B,KAAKuJ,YAErC,IAAiDC,EAIEhB,IAH/CiB,EAAYC,KACdF,QAAkBC,EAAY9D,QAG5ByD,EAAcM,KAChBlB,QAAiCY,EAACzD,QAGhC2D,EAAYI,KACd/B,QAA6B2B,EAAC3D,QAGhC3F,KAAKiJ,cAAcO,EAAWhB,EAAab,EAC7C,CAEAwB,YACE,MAAO,WAAWnJ,KAAKsI,6BAA6BtI,KAAK4H,UAC3D,CAEAyB,aACE,MAAO,WAAWrJ,KAAKsI,8BAA8BtI,KAAK4H,UAC5D,CAEA2B,WACE,MAAO,WAAWvJ,KAAKsI,sCAAsCtI,KAAK4H,UACpE,CAEApH,sBAAsBmJ,GACpB,IAAItI,EACJ,GAAIrB,KAAKW,QAAQ8H,MAAO,CACtB,cAAiC/G,MAAC,GAAG1B,KAAKW,QAAQ8H,0BAA0B,IAAIM,gBAAkBC,EAAAA,CAAAA,GAAIhJ,KAAKqI,SAAYsB,IAAUzE,cAEjI7D,SADgCuI,EAACjE,QACrB7C,OACb,KAAM,CACL,IAAK9C,KAAKuI,WACR,MAAUxH,IAAAA,MAAM,uDAElB,IAAKf,KAAKuI,WAAWsB,WAAaC,EAAM9J,KAAKuI,WAAWsB,UAAW,UAAe9I,MAAC,+CACnF,MAAiBgJ,EAAG,IAAOC,IAAChK,KAAKuI,WAAWsB,UAC5CE,EAAYE,OAAS,IAAmBlB,gBAACY,GAAQzE,WACjD,MAAmB0E,QAAclI,MAACqI,GAClC1I,UAA2BsE,MAC5B,CAED,MAAMnB,EAAiBnD,GAAQA,EAAKsD,IAAMtD,EAAKsD,GAAGO,WAClD,IAAKV,EAAgB,UAAezD,MAAC,+BAErC,MAAiBmJ,EAAgB,CAAEvF,GAAIH,GAGvC,OAFInD,GAAQA,EAAKqD,SAAQwF,EAAYxF,OAASrD,EAAKqD,OAAOQ,YAEnD,MAAYgF,EACrB,CAEA1J,qBAAqB4C,GACnB,IAAKpD,KAAKuI,WACR,MAAM,IAASxH,MAAC,uDAElB,QAA4B,IAAfqC,EAAK0C,SACZqE,eAAEA,EAAcjG,IAAEA,EAAGC,IAAEA,GAAQnE,KAAKuI,WAE1C,IAAKtE,EAAc,CAAEZ,OAAQ+G,EAAMlG,MAAKC,QACtC,MAAM,IAASpD,MAAC,kBAClB,GAAIqC,EAAK2C,SAAWoE,GAAkBA,EAAiB,GAAK/G,EAAK2C,QAAQsB,OAAS8C,EAChF,MAAM,IAASpJ,oCACiBoJ,yBAGlC,MAAME,EAA0E,CAAEhH,OAAQ+G,EAAKlF,YAI/F,OAHI9B,EAAK2C,UAASsE,EAActE,QAAU3C,EAAK2C,SAC3C3C,EAAKkH,YAAWD,EAAcC,UAAYhJ,KAAK4B,UAAUE,EAAKkH,YAEvDtK,KAACuK,gBAAgBF,EAC9B,CAEA7J,YAAY2C,EAAcE,EAAiB,GACzC,IAAKrD,KAAKwI,YACR,UAAezH,MAAC,wDAElB,MAAM2C,YAAEA,EAAWE,UAAEA,EAASC,YAAEA,GAAgB7D,KAAKwI,YACrD,OAAOgC,EAAQ,CACb9G,cACAE,YACAC,cACAR,SAAMF,MACNA,GACC,CACDtC,MAAOb,KAAKa,OAEhB,CAEAL,kBAAiBsF,QACfA,EAAOC,QAAEA,EAAOE,OAAEA,EAAM5D,EAAEA,GAChB1B,EAAsB,CAAA,GAChC,IAAKX,KAAKuI,WACR,UAAexH,MAAC,uDAElB,IAAKf,KAAK6H,YACR,MAAU9G,IAAAA,MAAM,2BAElB,MAAOiF,EAAGhG,KAAK6H,YACTuC,EAAiB,IAAVtE,GACP2E,YAAEA,EAAWvG,IAAEA,EAAGC,IAAEA,GAAQnE,KAAKuI,WAEvC,IAAKtE,EAAc,CAAEZ,OAAQ+G,EAAMlG,MAAKC,QACtC,MAAM,IAASpD,MAAC,kBAClB,IAAK0J,EAAa,MAAM,IAAS1J,MAAC,uCAElC,MAAMkG,QAA8BpB,EAAC,CACnCC,QAASsE,EAAMrE,UAASC,IAAG3D,IAAG4D,UAC7BtF,GACG+J,EAA+C,CACnDrH,OAAQ+G,EAAKlF,WACbgB,MAAO5E,KAAK4B,UAAU+D,IAIxB,aAD0BjH,KAACuK,gBAAgBG,EAE7C,CAEAlK,UAAU4C,EAAezC,EAAsB,CAAE,GAC/C,MAAamC,EAAG9C,KAAK2K,WAAWvH,EAAMzC,GACtC,IAAKX,KAAKa,MAER,MAAUE,IAAAA,MAAM,uBAIlB,aAFUf,KAACa,MAAMkC,SACA/C,KAAKa,MAAMoC,mBAA0BH,GAAE0B,eAE1D,CAEQyE,cAAcV,EAAgDC,EAAiDb,GACjHY,IACFvI,KAAKuI,WJ/KTlH,KAEA,GANsB,eAMlBA,EAAKiG,IAAyB,UAAevG,MAAC,8BAElD,MAAc8I,GAAIxI,EAAKwI,SAAW,IAAIvH,OACtC,IAAKwH,EAAMD,GAAW,MAAM,UAAU,gCAEtC,QAAYvG,KAAKsH,KAAKC,OAAOxJ,EAAKyJ,aAAe,IACxC3G,EAAGb,KAAKC,MAAMsH,OAAOxJ,EAAK0J,cACnC,IAAM7G,IAAOC,GAAQD,EAAMC,EAAK,MAAM,IAASpD,MAAC,8BAEhD,IAAIiK,EACAC,EACJ,IACED,EAAW1J,KAAKC,MAAMF,EAAK2J,SAAW,IACtCC,EAAezF,EAAOnE,EAAK2J,SAAW,IAAI9F,SAASO,EAIpD,CAHC,SACAuF,EAAW,GACXC,EAAezF,EAAO,MAAMN,SAASO,EACtC,CAED,IAASyF,EAAG,GACRC,EAAc,GACJC,EAAG,GACjB,IAAK,IAAKhE,EAAG,EAAGA,EAAI4D,EAAS3D,OAAQD,IAAK,CACxC,MAAOiE,EAAGC,GAAKN,EAAS5D,GACxB,OAAQiE,GACN,IAAK,aACHF,EAAcG,EACd,MACF,IAAK,kBACHF,EAAaE,EACb,MACF,IAAK,mBACL,IAAK,oBACHJ,EAAQ,QAAUG,EAAI,IAAMC,EAGjC,CACD,MAAIC,EAAYlK,EAAKkK,UAGrB,IACEjD,EAAS,IAAO0B,IAACH,GAAU2B,QAK7B,CAJE,MAAAC,GAIF,CAAA,MAAO,CACL5B,WACA6B,MAAOxH,IAAQC,EACfD,MACAC,MACAmE,SACA0C,WACAC,eACAG,aACAD,cACAD,QACAK,YACApB,eAAgBU,OAAOxJ,EAAK8I,iBAAmB,EAC/CwB,QAAStK,EACToJ,YAAapJ,EAAKoJ,cAAe,IIiHbmB,CAAsBrD,IAEtCC,IACFxI,KAAKwI,YL3MTnH,KAEA,GALkB,YAKdA,EAAKiG,IAAqB,UAAevG,MAAC,0BAC9C,GAAoB,OAAhBM,EAAKwK,OAAiB,MAAM,UAAU,yBAE1C,KAAM,cAAexK,EAAKyK,WAAW,KAA0C,UAAnCzK,EAAKyK,WAAW,GAAc,UACxE,UAAe/K,MAAC,4BAElB,KAAM,kBAAsB+K,WAAW,MAAQzK,EAAKyK,WAAW,GAAgB,YAC7E,MAAU/K,IAAAA,MAAM,8BAElB,IAAKM,EAAKiF,OACR,MAAM,UAAU,yBAMlB,MAAO,CACL5C,YALmBrC,EAAKiF,OAMxB1C,UALgBvC,EAAKyK,WAAW,GAAc,UAM9CjI,YALkBxC,EAAKyK,WAAW,GAAgB,cK2L7BC,CAAqBvD,IAEtCb,KACD3H,KAAK2H,UAAW3H,KAAK6H,YAAa7H,KAAK8H,aAAekE,EAAmBrE,EAAW3H,KAAK4H,UAE9F,ECrNF,MAE2BqE,EAAGzL,UAC5B,QAAY,iCAAmC0L,EAAStD,cAAgB,QAClE7E,QAAiBrC,MAAMjB,GAG7B,eAF4BkF,QAEhBwG,WAPO,GAOMC,IAGC5L,OAASsF,UAASoG,eAC5C,gBAAkCA,GAElC,OAAarB,OAAC/E,GAAWuG,yEAGI7L,OAAS6C,SAAQ6I,eAC9C,MAAUG,QAAuBJ,EAACC,GAElC,OAAW5I,KAACC,MAAMsH,OAAOxH,GAAUgJ,EAAI,wBAGJ7L,OAASsF,UAASoG,WAAUI,aAC1DA,IACHA,EAAS,aAEaC,EAAa,CAAEzG,UAASoG,cAC/BM,eAAeF,EAAQ,CACtCG,MAAO,WACPP"}