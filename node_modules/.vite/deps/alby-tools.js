import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-HYZYPRER.js";

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof global !== "undefined" && global.crypto) {
          crypto = global.crypto;
        }
        if (!crypto && typeof __require === "function") {
          try {
            crypto = require_crypto();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i2 = 0; i2 < thatSigBytes; i2++) {
                var thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
                thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i2 = 0; i2 < nBytes; i2 += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i2 = 0; i2 < hexStrLength; i2 += 2) {
              words[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i2 = 0; i2 < sigBytes; i2++) {
              var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i2 = 0; i2 < latin1StrLength; i2++) {
              words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e2) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/enc-hex.js
var require_enc_hex = __commonJS({
  "node_modules/crypto-js/enc-hex.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      return CryptoJS.enc.Hex;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n3) {
            var sqrtN = Math2.sqrt(n3);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n3 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n3) {
            return (n3 - (n3 | 0)) * 4294967296 | 0;
          }
          var n2 = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n2)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n2, 1 / 3));
              nPrime++;
            }
            n2++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a2 = H2[0];
            var b2 = H2[1];
            var c2 = H2[2];
            var d2 = H2[3];
            var e2 = H2[4];
            var f2 = H2[5];
            var g2 = H2[6];
            var h2 = H2[7];
            for (var i2 = 0; i2 < 64; i2++) {
              if (i2 < 16) {
                W[i2] = M[offset + i2] | 0;
              } else {
                var gamma0x = W[i2 - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i2 - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i2] = gamma0 + W[i2 - 7] + gamma1 + W[i2 - 16];
              }
              var ch = e2 & f2 ^ ~e2 & g2;
              var maj = a2 & b2 ^ a2 & c2 ^ b2 & c2;
              var sigma0 = (a2 << 30 | a2 >>> 2) ^ (a2 << 19 | a2 >>> 13) ^ (a2 << 10 | a2 >>> 22);
              var sigma1 = (e2 << 26 | e2 >>> 6) ^ (e2 << 21 | e2 >>> 11) ^ (e2 << 7 | e2 >>> 25);
              var t1 = h2 + sigma1 + ch + K[i2] + W[i2];
              var t2 = sigma0 + maj;
              h2 = g2;
              g2 = f2;
              f2 = e2;
              e2 = d2 + t1 | 0;
              d2 = c2;
              c2 = b2;
              b2 = a2;
              a2 = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a2 | 0;
            H2[1] = H2[1] + b2 | 0;
            H2[2] = H2[2] + c2 | 0;
            H2[3] = H2[3] + d2 | 0;
            H2[4] = H2[4] + e2 | 0;
            H2[5] = H2[5] + f2 | 0;
            H2[6] = H2[6] + g2 | 0;
            H2[7] = H2[7] + h2 | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// node_modules/@scure/base/lib/index.js
var require_lib = __commonJS({
  "node_modules/@scure/base/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;
    function assertNumber(n2) {
      if (!Number.isSafeInteger(n2))
        throw new Error(`Wrong integer: ${n2}`);
    }
    exports.assertNumber = assertNumber;
    function chain(...args) {
      const wrap = (a2, b2) => (c2) => a2(b2(c2));
      const encode = Array.from(args).reverse().reduce((acc, i2) => acc ? wrap(acc, i2.encode) : i2.encode, void 0);
      const decode = args.reduce((acc, i2) => acc ? wrap(acc, i2.decode) : i2.decode, void 0);
      return { encode, decode };
    }
    function alphabet(alphabet2) {
      return {
        encode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("alphabet.encode input should be an array of numbers");
          return digits.map((i2) => {
            assertNumber(i2);
            if (i2 < 0 || i2 >= alphabet2.length)
              throw new Error(`Digit index outside alphabet: ${i2} (alphabet: ${alphabet2.length})`);
            return alphabet2[i2];
          });
        },
        decode: (input) => {
          if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
            throw new Error("alphabet.decode input should be array of strings");
          return input.map((letter) => {
            if (typeof letter !== "string")
              throw new Error(`alphabet.decode: not string element=${letter}`);
            const index = alphabet2.indexOf(letter);
            if (index === -1)
              throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
            return index;
          });
        }
      };
    }
    function join(separator = "") {
      if (typeof separator !== "string")
        throw new Error("join separator should be string");
      return {
        encode: (from) => {
          if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
            throw new Error("join.encode input should be array of strings");
          for (let i2 of from)
            if (typeof i2 !== "string")
              throw new Error(`join.encode: non-string input=${i2}`);
          return from.join(separator);
        },
        decode: (to) => {
          if (typeof to !== "string")
            throw new Error("join.decode input should be string");
          return to.split(separator);
        }
      };
    }
    function padding(bits, chr = "=") {
      assertNumber(bits);
      if (typeof chr !== "string")
        throw new Error("padding chr should be string");
      return {
        encode(data) {
          if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
            throw new Error("padding.encode input should be array of strings");
          for (let i2 of data)
            if (typeof i2 !== "string")
              throw new Error(`padding.encode: non-string input=${i2}`);
          while (data.length * bits % 8)
            data.push(chr);
          return data;
        },
        decode(input) {
          if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
            throw new Error("padding.encode input should be array of strings");
          for (let i2 of input)
            if (typeof i2 !== "string")
              throw new Error(`padding.decode: non-string input=${i2}`);
          let end = input.length;
          if (end * bits % 8)
            throw new Error("Invalid padding: string should have whole number of bytes");
          for (; end > 0 && input[end - 1] === chr; end--) {
            if (!((end - 1) * bits % 8))
              throw new Error("Invalid padding: string has too much padding");
          }
          return input.slice(0, end);
        }
      };
    }
    function normalize(fn) {
      if (typeof fn !== "function")
        throw new Error("normalize fn should be function");
      return { encode: (from) => from, decode: (to) => fn(to) };
    }
    function convertRadix(data, from, to) {
      if (from < 2)
        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
      if (to < 2)
        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
      if (!Array.isArray(data))
        throw new Error("convertRadix: data should be array");
      if (!data.length)
        return [];
      let pos = 0;
      const res = [];
      const digits = Array.from(data);
      digits.forEach((d2) => {
        assertNumber(d2);
        if (d2 < 0 || d2 >= from)
          throw new Error(`Wrong integer: ${d2}`);
      });
      while (true) {
        let carry = 0;
        let done = true;
        for (let i2 = pos; i2 < digits.length; i2++) {
          const digit = digits[i2];
          const digitBase = from * carry + digit;
          if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
            throw new Error("convertRadix: carry overflow");
          }
          carry = digitBase % to;
          digits[i2] = Math.floor(digitBase / to);
          if (!Number.isSafeInteger(digits[i2]) || digits[i2] * to + carry !== digitBase)
            throw new Error("convertRadix: carry overflow");
          if (!done)
            continue;
          else if (!digits[i2])
            pos = i2;
          else
            done = false;
        }
        res.push(carry);
        if (done)
          break;
      }
      for (let i2 = 0; i2 < data.length - 1 && data[i2] === 0; i2++)
        res.push(0);
      return res.reverse();
    }
    var gcd = (a2, b2) => !b2 ? a2 : gcd(b2, a2 % b2);
    var radix2carry = (from, to) => from + (to - gcd(from, to));
    function convertRadix2(data, from, to, padding2) {
      if (!Array.isArray(data))
        throw new Error("convertRadix2: data should be array");
      if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
      if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
      if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
      }
      let carry = 0;
      let pos = 0;
      const mask = 2 ** to - 1;
      const res = [];
      for (const n2 of data) {
        assertNumber(n2);
        if (n2 >= 2 ** from)
          throw new Error(`convertRadix2: invalid data word=${n2} from=${from}`);
        carry = carry << from | n2;
        if (pos + from > 32)
          throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
          res.push((carry >> pos - to & mask) >>> 0);
        carry &= 2 ** pos - 1;
      }
      carry = carry << to - pos & mask;
      if (!padding2 && pos >= from)
        throw new Error("Excess padding");
      if (!padding2 && carry)
        throw new Error(`Non-zero padding: ${carry}`);
      if (padding2 && pos > 0)
        res.push(carry >>> 0);
      return res;
    }
    function radix(num) {
      assertNumber(num);
      return {
        encode: (bytes) => {
          if (!(bytes instanceof Uint8Array))
            throw new Error("radix.encode input should be Uint8Array");
          return convertRadix(Array.from(bytes), 2 ** 8, num);
        },
        decode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("radix.decode input should be array of strings");
          return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
        }
      };
    }
    function radix2(bits, revPadding = false) {
      assertNumber(bits);
      if (bits <= 0 || bits > 32)
        throw new Error("radix2: bits should be in (0..32]");
      if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
        throw new Error("radix2: carry overflow");
      return {
        encode: (bytes) => {
          if (!(bytes instanceof Uint8Array))
            throw new Error("radix2.encode input should be Uint8Array");
          return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("radix2.decode input should be array of strings");
          return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        }
      };
    }
    function unsafeWrapper(fn) {
      if (typeof fn !== "function")
        throw new Error("unsafeWrapper fn should be function");
      return function(...args) {
        try {
          return fn.apply(null, args);
        } catch (e2) {
        }
      };
    }
    function checksum(len, fn) {
      assertNumber(len);
      if (typeof fn !== "function")
        throw new Error("checksum fn should be function");
      return {
        encode(data) {
          if (!(data instanceof Uint8Array))
            throw new Error("checksum.encode: input should be Uint8Array");
          const checksum2 = fn(data).slice(0, len);
          const res = new Uint8Array(data.length + len);
          res.set(data);
          res.set(checksum2, data.length);
          return res;
        },
        decode(data) {
          if (!(data instanceof Uint8Array))
            throw new Error("checksum.decode: input should be Uint8Array");
          const payload = data.slice(0, -len);
          const newChecksum = fn(payload).slice(0, len);
          const oldChecksum = data.slice(-len);
          for (let i2 = 0; i2 < len; i2++)
            if (newChecksum[i2] !== oldChecksum[i2])
              throw new Error("Invalid checksum");
          return payload;
        }
      };
    }
    exports.utils = { alphabet, chain, checksum, radix, radix2, join, padding };
    exports.base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
    exports.base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
    exports.base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
    exports.base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s2) => s2.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
    exports.base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
    exports.base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
    var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
    exports.base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    exports.base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
    exports.base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
    exports.base58xmr = {
      encode(data) {
        let res = "";
        for (let i2 = 0; i2 < data.length; i2 += 8) {
          const block = data.subarray(i2, i2 + 8);
          res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
        }
        return res;
      },
      decode(str) {
        let res = [];
        for (let i2 = 0; i2 < str.length; i2 += 11) {
          const slice = str.slice(i2, i2 + 11);
          const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
          const block = exports.base58.decode(slice);
          for (let j = 0; j < block.length - blockLen; j++) {
            if (block[j] !== 0)
              throw new Error("base58xmr: wrong padding");
          }
          res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
      }
    };
    var base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);
    exports.base58check = base58check;
    var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
    var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
    function bech32Polymod(pre) {
      const b2 = pre >> 25;
      let chk = (pre & 33554431) << 5;
      for (let i2 = 0; i2 < POLYMOD_GENERATORS.length; i2++) {
        if ((b2 >> i2 & 1) === 1)
          chk ^= POLYMOD_GENERATORS[i2];
      }
      return chk;
    }
    function bechChecksum(prefix, words, encodingConst = 1) {
      const len = prefix.length;
      let chk = 1;
      for (let i2 = 0; i2 < len; i2++) {
        const c2 = prefix.charCodeAt(i2);
        if (c2 < 33 || c2 > 126)
          throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ c2 >> 5;
      }
      chk = bech32Polymod(chk);
      for (let i2 = 0; i2 < len; i2++)
        chk = bech32Polymod(chk) ^ prefix.charCodeAt(i2) & 31;
      for (let v2 of words)
        chk = bech32Polymod(chk) ^ v2;
      for (let i2 = 0; i2 < 6; i2++)
        chk = bech32Polymod(chk);
      chk ^= encodingConst;
      return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
    }
    function genBech32(encoding) {
      const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
      const _words = radix2(5);
      const fromWords = _words.decode;
      const toWords = _words.encode;
      const fromWordsUnsafe = unsafeWrapper(fromWords);
      function encode(prefix, words, limit = 90) {
        if (typeof prefix !== "string")
          throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
        if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
          throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
        const actualLength = prefix.length + 7 + words.length;
        if (limit !== false && actualLength > limit)
          throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        prefix = prefix.toLowerCase();
        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;
      }
      function decode(str, limit = 90) {
        if (typeof str !== "string")
          throw new Error(`bech32.decode input should be string, not ${typeof str}`);
        if (str.length < 8 || limit !== false && str.length > limit)
          throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
          throw new Error(`String must be lowercase or uppercase`);
        str = lowered;
        const sepIndex = str.lastIndexOf("1");
        if (sepIndex === 0 || sepIndex === -1)
          throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = str.slice(0, sepIndex);
        const _words2 = str.slice(sepIndex + 1);
        if (_words2.length < 6)
          throw new Error("Data must be at least 6 characters long");
        const words = BECH_ALPHABET.decode(_words2).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!_words2.endsWith(sum))
          throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
      }
      const decodeUnsafe = unsafeWrapper(decode);
      function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return { prefix, words, bytes: fromWords(words) };
      }
      return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
    }
    exports.bech32 = genBech32("bech32");
    exports.bech32m = genBech32("bech32m");
    exports.utf8 = {
      encode: (data) => new TextDecoder().decode(data),
      decode: (str) => new TextEncoder().encode(str)
    };
    exports.hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s2) => {
      if (typeof s2 !== "string" || s2.length % 2)
        throw new TypeError(`hex.decode: expected string, got ${typeof s2} with length ${s2.length}`);
      return s2.toLowerCase();
    }));
    var CODERS = {
      utf8: exports.utf8,
      hex: exports.hex,
      base16: exports.base16,
      base32: exports.base32,
      base64: exports.base64,
      base64url: exports.base64url,
      base58: exports.base58,
      base58xmr: exports.base58xmr
    };
    var coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(", ")}`;
    var bytesToString = (type, bytes) => {
      if (typeof type !== "string" || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (!(bytes instanceof Uint8Array))
        throw new TypeError("bytesToString() expects Uint8Array");
      return CODERS[type].encode(bytes);
    };
    exports.bytesToString = bytesToString;
    exports.str = exports.bytesToString;
    var stringToBytes = (type, str) => {
      if (!CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (typeof str !== "string")
        throw new TypeError("stringToBytes() expects string");
      return CODERS[type].decode(str);
    };
    exports.stringToBytes = stringToBytes;
    exports.bytes = exports.stringToBytes;
  }
});

// node_modules/light-bolt11-decoder/bolt11.js
var require_bolt11 = __commonJS({
  "node_modules/light-bolt11-decoder/bolt11.js"(exports, module) {
    var { bech32, hex, utf8 } = require_lib();
    var DEFAULTNETWORK = {
      // default network is bitcoin
      bech32: "bc",
      pubKeyHash: 0,
      scriptHash: 5,
      validWitnessVersions: [0]
    };
    var TESTNETWORK = {
      bech32: "tb",
      pubKeyHash: 111,
      scriptHash: 196,
      validWitnessVersions: [0]
    };
    var REGTESTNETWORK = {
      bech32: "bcrt",
      pubKeyHash: 111,
      scriptHash: 196,
      validWitnessVersions: [0]
    };
    var SIMNETWORK = {
      bech32: "sb",
      pubKeyHash: 63,
      scriptHash: 123,
      validWitnessVersions: [0]
    };
    var FEATUREBIT_ORDER = [
      "option_data_loss_protect",
      "initial_routing_sync",
      "option_upfront_shutdown_script",
      "gossip_queries",
      "var_onion_optin",
      "gossip_queries_ex",
      "option_static_remotekey",
      "payment_secret",
      "basic_mpp",
      "option_support_large_channel"
    ];
    var DIVISORS = {
      m: BigInt(1e3),
      u: BigInt(1e6),
      n: BigInt(1e9),
      p: BigInt(1e12)
    };
    var MAX_MILLISATS = BigInt("2100000000000000000");
    var MILLISATS_PER_BTC = BigInt(1e11);
    var TAGCODES = {
      payment_hash: 1,
      payment_secret: 16,
      description: 13,
      payee: 19,
      description_hash: 23,
      // commit to longer descriptions (used by lnurl-pay)
      expiry: 6,
      // default: 3600 (1 hour)
      min_final_cltv_expiry: 24,
      // default: 9
      fallback_address: 9,
      route_hint: 3,
      // for extra routing info (private etc.)
      feature_bits: 5,
      metadata: 27
    };
    var TAGNAMES = {};
    for (let i2 = 0, keys = Object.keys(TAGCODES); i2 < keys.length; i2++) {
      const currentName = keys[i2];
      const currentCode = TAGCODES[keys[i2]].toString();
      TAGNAMES[currentCode] = currentName;
    }
    var TAGPARSERS = {
      1: (words) => hex.encode(bech32.fromWordsUnsafe(words)),
      // 256 bits
      16: (words) => hex.encode(bech32.fromWordsUnsafe(words)),
      // 256 bits
      13: (words) => utf8.encode(bech32.fromWordsUnsafe(words)),
      // string variable length
      19: (words) => hex.encode(bech32.fromWordsUnsafe(words)),
      // 264 bits
      23: (words) => hex.encode(bech32.fromWordsUnsafe(words)),
      // 256 bits
      27: (words) => hex.encode(bech32.fromWordsUnsafe(words)),
      // variable
      6: wordsToIntBE,
      // default: 3600 (1 hour)
      24: wordsToIntBE,
      // default: 9
      3: routingInfoParser,
      // for extra routing info (private etc.)
      5: featureBitsParser
      // keep feature bits as array of 5 bit words
    };
    function getUnknownParser(tagCode) {
      return (words) => ({
        tagCode: parseInt(tagCode),
        words: bech32.encode("unknown", words, Number.MAX_SAFE_INTEGER)
      });
    }
    function wordsToIntBE(words) {
      return words.reverse().reduce((total, item, index) => {
        return total + item * Math.pow(32, index);
      }, 0);
    }
    function routingInfoParser(words) {
      const routes = [];
      let pubkey, shortChannelId, feeBaseMSats, feeProportionalMillionths, cltvExpiryDelta;
      let routesBuffer = bech32.fromWordsUnsafe(words);
      while (routesBuffer.length > 0) {
        pubkey = hex.encode(routesBuffer.slice(0, 33));
        shortChannelId = hex.encode(routesBuffer.slice(33, 41));
        feeBaseMSats = parseInt(hex.encode(routesBuffer.slice(41, 45)), 16);
        feeProportionalMillionths = parseInt(
          hex.encode(routesBuffer.slice(45, 49)),
          16
        );
        cltvExpiryDelta = parseInt(hex.encode(routesBuffer.slice(49, 51)), 16);
        routesBuffer = routesBuffer.slice(51);
        routes.push({
          pubkey,
          short_channel_id: shortChannelId,
          fee_base_msat: feeBaseMSats,
          fee_proportional_millionths: feeProportionalMillionths,
          cltv_expiry_delta: cltvExpiryDelta
        });
      }
      return routes;
    }
    function featureBitsParser(words) {
      const bools = words.slice().reverse().map((word) => [
        !!(word & 1),
        !!(word & 2),
        !!(word & 4),
        !!(word & 8),
        !!(word & 16)
      ]).reduce((finalArr, itemArr) => finalArr.concat(itemArr), []);
      while (bools.length < FEATUREBIT_ORDER.length * 2) {
        bools.push(false);
      }
      const featureBits = {};
      FEATUREBIT_ORDER.forEach((featureName, index) => {
        let status;
        if (bools[index * 2]) {
          status = "required";
        } else if (bools[index * 2 + 1]) {
          status = "supported";
        } else {
          status = "unsupported";
        }
        featureBits[featureName] = status;
      });
      const extraBits = bools.slice(FEATUREBIT_ORDER.length * 2);
      featureBits.extra_bits = {
        start_bit: FEATUREBIT_ORDER.length * 2,
        bits: extraBits,
        has_required: extraBits.reduce(
          (result, bit, index) => index % 2 !== 0 ? result || false : result || bit,
          false
        )
      };
      return featureBits;
    }
    function hrpToMillisat(hrpString, outputString) {
      let divisor, value;
      if (hrpString.slice(-1).match(/^[munp]$/)) {
        divisor = hrpString.slice(-1);
        value = hrpString.slice(0, -1);
      } else if (hrpString.slice(-1).match(/^[^munp0-9]$/)) {
        throw new Error("Not a valid multiplier for the amount");
      } else {
        value = hrpString;
      }
      if (!value.match(/^\d+$/))
        throw new Error("Not a valid human readable amount");
      const valueBN = BigInt(value);
      const millisatoshisBN = divisor ? valueBN * MILLISATS_PER_BTC / DIVISORS[divisor] : valueBN * MILLISATS_PER_BTC;
      if (divisor === "p" && !(valueBN % BigInt(10) === BigInt(0)) || millisatoshisBN > MAX_MILLISATS) {
        throw new Error("Amount is outside of valid range");
      }
      return outputString ? millisatoshisBN.toString() : millisatoshisBN;
    }
    function decode(paymentRequest, network) {
      if (typeof paymentRequest !== "string")
        throw new Error("Lightning Payment Request must be string");
      if (paymentRequest.slice(0, 2).toLowerCase() !== "ln")
        throw new Error("Not a proper lightning payment request");
      const sections = [];
      const decoded = bech32.decode(paymentRequest, Number.MAX_SAFE_INTEGER);
      paymentRequest = paymentRequest.toLowerCase();
      const prefix = decoded.prefix;
      let words = decoded.words;
      let letters = paymentRequest.slice(prefix.length + 1);
      let sigWords = words.slice(-104);
      words = words.slice(0, -104);
      let prefixMatches = prefix.match(/^ln(\S+?)(\d*)([a-zA-Z]?)$/);
      if (prefixMatches && !prefixMatches[2])
        prefixMatches = prefix.match(/^ln(\S+)$/);
      if (!prefixMatches) {
        throw new Error("Not a proper lightning payment request");
      }
      sections.push({
        name: "lightning_network",
        letters: "ln"
      });
      const bech32Prefix = prefixMatches[1];
      let coinNetwork;
      if (!network) {
        switch (bech32Prefix) {
          case DEFAULTNETWORK.bech32:
            coinNetwork = DEFAULTNETWORK;
            break;
          case TESTNETWORK.bech32:
            coinNetwork = TESTNETWORK;
            break;
          case REGTESTNETWORK.bech32:
            coinNetwork = REGTESTNETWORK;
            break;
          case SIMNETWORK.bech32:
            coinNetwork = SIMNETWORK;
            break;
        }
      } else {
        if (network.bech32 === void 0 || network.pubKeyHash === void 0 || network.scriptHash === void 0 || !Array.isArray(network.validWitnessVersions))
          throw new Error("Invalid network");
        coinNetwork = network;
      }
      if (!coinNetwork || coinNetwork.bech32 !== bech32Prefix) {
        throw new Error("Unknown coin bech32 prefix");
      }
      sections.push({
        name: "coin_network",
        letters: bech32Prefix,
        value: coinNetwork
      });
      const value = prefixMatches[2];
      let millisatoshis;
      if (value) {
        const divisor = prefixMatches[3];
        millisatoshis = hrpToMillisat(value + divisor, true);
        sections.push({
          name: "amount",
          letters: prefixMatches[2] + prefixMatches[3],
          value: millisatoshis
        });
      } else {
        millisatoshis = null;
      }
      sections.push({
        name: "separator",
        letters: "1"
      });
      const timestamp = wordsToIntBE(words.slice(0, 7));
      words = words.slice(7);
      sections.push({
        name: "timestamp",
        letters: letters.slice(0, 7),
        value: timestamp
      });
      letters = letters.slice(7);
      let tagName, parser, tagLength, tagWords;
      while (words.length > 0) {
        const tagCode = words[0].toString();
        tagName = TAGNAMES[tagCode] || "unknown_tag";
        parser = TAGPARSERS[tagCode] || getUnknownParser(tagCode);
        words = words.slice(1);
        tagLength = wordsToIntBE(words.slice(0, 2));
        words = words.slice(2);
        tagWords = words.slice(0, tagLength);
        words = words.slice(tagLength);
        sections.push({
          name: tagName,
          tag: letters[0],
          letters: letters.slice(0, 1 + 2 + tagLength),
          value: parser(tagWords)
          // see: parsers for more comments
        });
        letters = letters.slice(1 + 2 + tagLength);
      }
      sections.push({
        name: "signature",
        letters: letters.slice(0, 104),
        value: hex.encode(bech32.fromWordsUnsafe(sigWords))
      });
      letters = letters.slice(104);
      sections.push({
        name: "checksum",
        letters
      });
      let result = {
        paymentRequest,
        sections,
        get expiry() {
          let exp = sections.find((s2) => s2.name === "expiry");
          if (exp)
            return getValue("timestamp") + exp.value;
        },
        get route_hints() {
          return sections.filter((s2) => s2.name === "route_hint").map((s2) => s2.value);
        }
      };
      for (let name in TAGCODES) {
        if (name === "route_hint") {
          continue;
        }
        Object.defineProperty(result, name, {
          get() {
            return getValue(name);
          }
        });
      }
      return result;
      function getValue(name) {
        let section = sections.find((s2) => s2.name === name);
        return section ? section.value : void 0;
      }
    }
    module.exports = {
      decode,
      hrpToMillisat
    };
  }
});

// node_modules/alby-tools/dist/index.modern.js
var import_enc_hex = __toESM(require_enc_hex());
var import_sha256 = __toESM(require_sha256());
var import_light_bolt11_decoder = __toESM(require_bolt11());
var r = class {
  constructor(t2) {
    this.storage = void 0, this.storage = t2 || {};
  }
  getItem(t2) {
    return this.storage[t2];
  }
  setItem(t2, e2) {
    this.storage[t2] = e2;
  }
};
var n = { __proto__: null, MemoryStorage: r, NoStorage: class {
  constructor(t2) {
  }
  getItem(t2) {
    return null;
  }
  setItem(t2, e2) {
  }
}, default: r };
var s = new r();
var o = async (t2, e2, a2) => {
  a2 || (a2 = {});
  const r2 = a2.headerKey || "L402", n2 = a2.webln || globalThis.webln;
  if (!n2)
    throw new Error("WebLN is missing");
  let o2 = a2.store || s;
  e2 || (e2 = {}), e2.cache = "no-store", e2.mode = "cors", e2.headers || (e2.headers = {});
  const i2 = o2.getItem(t2);
  if (i2) {
    const a3 = JSON.parse(i2);
    return e2.headers.Authorization = `${r2} ${a3.token}:${a3.preimage}`, await fetch(t2, e2);
  }
  e2.headers["Accept-Authenticate"] = r2;
  const l2 = await fetch(t2, e2), c2 = l2.headers.get("www-authenticate");
  if (!c2)
    return l2;
  const h2 = ((t3) => {
    const e3 = (t3 = (t3 = t3.replace("L402", "")).replace("LSAT", "")).split(",").map((t4) => {
      const [e4, a3] = t4.split("=").map((t5) => t5.trim());
      return [e4, a3.match(/"?([^"]*)"?/)[1]];
    });
    return Object.fromEntries(e3);
  })(c2), u2 = h2.token || h2.macaroon, m2 = h2.invoice;
  await n2.enable();
  const p2 = await n2.sendPayment(m2);
  return o2.setItem(t2, JSON.stringify({ token: u2, preimage: p2.preimage })), e2.headers.Authorization = `${r2} ${u2}:${p2.preimage}`, await fetch(t2, e2);
};
var i = { __proto__: null, storage: n, fetchWithL402: o, default: o };
var l = async (t2, e2) => {
  let { boost: a2, amount: r2 } = t2;
  e2 || (e2 = {});
  const n2 = e2.webln || globalThis.webln;
  r2 || (r2 = Math.floor(a2.value_msat / 1e3));
  let s2 = { destination: t2.destination, amount: r2, customRecords: { 7629169: JSON.stringify(a2) } };
  return t2.customKey && t2.customValue && (s2.customRecords[t2.customKey] = t2.customValue), await n2.enable(), await n2.keysend(s2);
};
var c = { __proto__: null, boost: l, default: l };
function h() {
  return h = Object.assign ? Object.assign.bind() : function(t2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var a2 = arguments[e2];
      for (var r2 in a2)
        Object.prototype.hasOwnProperty.call(a2, r2) && (t2[r2] = a2[r2]);
    }
    return t2;
  }, h.apply(this, arguments);
}
var u = /((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=\+\$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=\+\$,\w]+@)[A-Za-z0-9.-]+)((?:\/[\+~%\/.\w-_]*)?\??(?:[-\+=&;%@.\w_]*)#?(?:[\w]*))?)/;
var m = (t2) => !!t2 && u.test(t2);
var p = ({ amount: t2, min: e2, max: a2 }) => {
  const r2 = t2 > 0 && t2 >= e2 && t2 <= a2;
  return r2 && e2 === a2 ? t2 === e2 : r2;
};
var w = class {
  constructor(t2) {
    var e2, r2;
    this.paymentRequest = void 0, this.paymentHash = void 0, this.preimage = void 0, this.verify = void 0, this.paymentRequest = t2.pr, this.paymentHash = ((t3) => {
      if (!t3)
        return null;
      try {
        const e3 = (0, import_light_bolt11_decoder.decode)(t3);
        if (!e3 || !e3.sections)
          return null;
        const r3 = e3.sections.find((t4) => "payment_hash" === t4.name);
        return r3 && r3.value ? r3.value.toString() : null;
      } catch (t4) {
        return null;
      }
    })(this.paymentRequest), this.verify = null != (e2 = t2.verify) ? e2 : null, this.preimage = null != (r2 = t2.preimage) ? r2 : null;
  }
  async isPaid() {
    if (this.preimage)
      return this.validatePreimage(this.preimage);
    if (this.verify)
      return await this.verifyPayment();
    throw new Error("Could not verify payment");
  }
  validatePreimage(a2) {
    if (!a2 || !this.paymentHash)
      return false;
    try {
      const r2 = (0, import_sha256.default)(import_enc_hex.default.parse(a2)).toString(import_enc_hex.default);
      return this.paymentHash === r2;
    } catch (t2) {
      return false;
    }
  }
  async verifyPayment() {
    if (!this.verify)
      throw new Error("LNURL verify not available");
    const t2 = await fetch(this.verify), e2 = await t2.json();
    return e2.preimage && (this.preimage = e2.preimage), e2.settled;
  }
};
async function y({ satoshi: t2, comment: e2, p: a2, e: r2, relays: n2 }, s2 = {}) {
  const o2 = s2.nostr || globalThis.nostr;
  if (!o2)
    throw new Error("nostr option or window.nostr is not available");
  const i2 = [["relays", ...n2], ["amount", t2.toString()]];
  a2 && i2.push(["p", a2]), r2 && i2.push(["e", r2]);
  const l2 = { pubkey: await o2.getPublicKey(), created_at: Math.floor(Date.now() / 1e3), kind: 9734, tags: i2, content: null != e2 ? e2 : "" };
  return l2.id = g(l2), await o2.signEvent(l2);
}
function d(t2) {
  if ("string" != typeof t2.content)
    return false;
  if ("number" != typeof t2.created_at)
    return false;
  if (!Array.isArray(t2.tags))
    return false;
  for (let e2 = 0; e2 < t2.tags.length; e2++) {
    const a2 = t2.tags[e2];
    if (!Array.isArray(a2))
      return false;
    for (let t3 = 0; t3 < a2.length; t3++)
      if ("object" == typeof a2[t3])
        return false;
  }
  return true;
}
function f(t2) {
  if (!d(t2))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, t2.pubkey, t2.created_at, t2.kind, t2.tags, t2.content]);
}
function g(a2) {
  return (0, import_sha256.default)(f(a2)).toString(import_enc_hex.default);
}
function v(t2, e2) {
  let a2, r2;
  var n2, s2;
  return e2 && t2 && (a2 = null == (n2 = t2.names) ? void 0 : n2[e2], r2 = a2 ? null == (s2 = t2.relays) ? void 0 : s2[a2] : void 0), [t2, a2, r2];
}
var b = { __proto__: null, generateZapEvent: y, validateEvent: d, serializeEvent: f, getEventHash: g, parseNostrResponse: v };
var k = /^((?:[^<>()\[\]\\.,;:\s@"]+(?:\.[^<>()\[\]\\.,;:\s@"]+)*)|(?:".+"))@((?:\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(?:(?:[a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var D = class {
  constructor(t2, e2) {
    this.address = void 0, this.options = void 0, this.username = void 0, this.domain = void 0, this.pubkey = void 0, this.lnurlpData = void 0, this.keysendData = void 0, this.nostrData = void 0, this.nostrPubkey = void 0, this.nostrRelays = void 0, this.webln = void 0, this.address = t2, this.options = { proxy: "https://lnaddressproxy.getalby.com", webln: globalThis.webln }, this.options = Object.assign(this.options, e2), this.parse(), this.webln = this.options.webln;
  }
  parse() {
    const t2 = k.exec(this.address.toLowerCase());
    t2 && (this.username = t2[1], this.domain = t2[2]);
  }
  async fetch() {
    return this.options.proxy ? this.fetchWithProxy() : this.fetchWithoutProxy();
  }
  async fetchWithProxy() {
    const t2 = await fetch(`${this.options.proxy}/lightning-address-details?${new URLSearchParams({ ln: this.address }).toString()}`), e2 = await t2.json();
    this.parseResponse(e2.lnurlp, e2.keysend, e2.nostr);
  }
  async fetchWithoutProxy() {
    if (!this.domain || !this.username)
      return;
    const t2 = await fetch(this.lnurlpUrl()), e2 = await fetch(this.keysendUrl()), a2 = await fetch(this.nostrUrl());
    let r2, n2, s2;
    t2.ok && (r2 = await t2.json()), e2.ok && (n2 = await e2.json()), a2.ok && (s2 = await a2.json()), this.parseResponse(r2, n2, s2);
  }
  lnurlpUrl() {
    return `https://${this.domain}/.well-known/lnurlp/${this.username}`;
  }
  keysendUrl() {
    return `https://${this.domain}/.well-known/keysend/${this.username}`;
  }
  nostrUrl() {
    return `https://${this.domain}/.well-known/nostr.json?name=${this.username}`;
  }
  async generateInvoice(t2) {
    let e2;
    if (this.options.proxy) {
      const a3 = await fetch(`${this.options.proxy}/generate-invoice?${new URLSearchParams(h({ ln: this.address }, t2)).toString()}`);
      e2 = (await a3.json()).invoice;
    } else {
      if (!this.lnurlpData)
        throw new Error("No lnurlpData available. Please call fetch() first.");
      if (!this.lnurlpData.callback || !m(this.lnurlpData.callback))
        throw new Error("Valid callback does not exist in lnurlpData");
      const a3 = new URL(this.lnurlpData.callback);
      a3.search = new URLSearchParams(t2).toString();
      const r3 = await fetch(a3);
      e2 = await r3.json();
    }
    const a2 = e2 && e2.pr && e2.pr.toString();
    if (!a2)
      throw new Error("Invalid pay service invoice");
    const r2 = { pr: a2 };
    return e2 && e2.verify && (r2.verify = e2.verify.toString()), new w(r2);
  }
  async requestInvoice(t2) {
    if (!this.lnurlpData)
      throw new Error("No lnurlpData available. Please call fetch() first.");
    const e2 = 1e3 * t2.satoshi, { commentAllowed: a2, min: r2, max: n2 } = this.lnurlpData;
    if (!p({ amount: e2, min: r2, max: n2 }))
      throw new Error("Invalid amount");
    if (t2.comment && a2 && a2 > 0 && t2.comment.length > a2)
      throw new Error(`The comment length must be ${a2} characters or fewer`);
    const s2 = { amount: e2.toString() };
    return t2.comment && (s2.comment = t2.comment), t2.payerdata && (s2.payerdata = JSON.stringify(t2.payerdata)), this.generateInvoice(s2);
  }
  async boost(t2, e2 = 0) {
    if (!this.keysendData)
      throw new Error("No keysendData available. Please call fetch() first.");
    const { destination: a2, customKey: r2, customValue: n2 } = this.keysendData;
    return l({ destination: a2, customKey: r2, customValue: n2, amount: e2, boost: t2 }, { webln: this.webln });
  }
  async zapInvoice({ satoshi: t2, comment: e2, relays: a2, e: r2 }, n2 = {}) {
    if (!this.lnurlpData)
      throw new Error("No lnurlpData available. Please call fetch() first.");
    if (!this.nostrPubkey)
      throw new Error("Nostr Pubkey is missing");
    const s2 = this.nostrPubkey, o2 = 1e3 * t2, { allowsNostr: i2, min: l2, max: c2 } = this.lnurlpData;
    if (!p({ amount: o2, min: l2, max: c2 }))
      throw new Error("Invalid amount");
    if (!i2)
      throw new Error("Your provider does not support zaps");
    const h2 = await y({ satoshi: o2, comment: e2, p: s2, e: r2, relays: a2 }, n2), u2 = { amount: o2.toString(), nostr: JSON.stringify(h2) };
    return await this.generateInvoice(u2);
  }
  async zap(t2, e2 = {}) {
    const a2 = this.zapInvoice(t2, e2);
    if (!this.webln)
      throw new Error("WebLN not available");
    return await this.webln.enable(), this.webln.sendPayment((await a2).paymentRequest);
  }
  parseResponse(a2, r2, n2) {
    a2 && (this.lnurlpData = ((a3) => {
      if ("payRequest" !== a3.tag)
        throw new Error("Invalid pay service params");
      const r3 = (a3.callback + "").trim();
      if (!m(r3))
        throw new Error("Callback must be a valid url");
      const n3 = Math.ceil(Number(a3.minSendable || 0)), s2 = Math.floor(Number(a3.maxSendable));
      if (!n3 || !s2 || n3 > s2)
        throw new Error("Invalid pay service params");
      let o2, i2;
      try {
        o2 = JSON.parse(a3.metadata + ""), i2 = (0, import_sha256.default)(a3.metadata + "").toString(import_enc_hex.default);
      } catch (a4) {
        o2 = [], i2 = (0, import_sha256.default)("[]").toString(import_enc_hex.default);
      }
      let l2 = "", c2 = "", h2 = "";
      for (let t2 = 0; t2 < o2.length; t2++) {
        const [e2, a4] = o2[t2];
        switch (e2) {
          case "text/plain":
            c2 = a4;
            break;
          case "text/identifier":
            h2 = a4;
            break;
          case "image/png;base64":
          case "image/jpeg;base64":
            l2 = "data:" + e2 + "," + a4;
        }
      }
      let u2, p2 = a3.payerData;
      try {
        u2 = new URL(r3).hostname;
      } catch (t2) {
      }
      return { callback: r3, fixed: n3 === s2, min: n3, max: s2, domain: u2, metadata: o2, metadataHash: i2, identifier: h2, description: c2, image: l2, payerData: p2, commentAllowed: Number(a3.commentAllowed) || 0, rawData: a3, allowsNostr: a3.allowsNostr || false };
    })(a2)), r2 && (this.keysendData = ((t2) => {
      if ("keysend" !== t2.tag)
        throw new Error("Invalid keysend params");
      if ("OK" !== t2.status)
        throw new Error("Keysend status not OK");
      if (!("customKey" in t2.customData[0]) || "696969" != t2.customData[0].customKey)
        throw new Error("Unable to find customKey");
      if (!("customValue" in t2.customData[0]) || !t2.customData[0].customValue)
        throw new Error("Unable to find customValue");
      if (!t2.pubkey)
        throw new Error("Pubkey does not exist");
      return { destination: t2.pubkey, customKey: t2.customData[0].customKey, customValue: t2.customData[0].customValue };
    })(r2)), n2 && ([this.nostrData, this.nostrPubkey, this.nostrRelays] = v(n2, this.username));
  }
};
var E = async (t2) => {
  const e2 = "https://getalby.com/api/rates/" + t2.toLowerCase() + ".json", a2 = await fetch(e2);
  return (await a2.json()).rate_float / 1e8;
};
var S = async ({ satoshi: t2, currency: e2 }) => {
  const a2 = await E(e2);
  return Number(t2) * a2;
};
var _ = { __proto__: null, getFiatBtcRate: E, getFiatValue: S, getSatoshiValue: async ({ amount: t2, currency: e2 }) => {
  const a2 = await E(e2);
  return Math.floor(Number(t2) / a2);
}, getFormattedFiatValue: async ({ satoshi: t2, currency: e2, locale: a2 }) => (a2 || (a2 = "en"), (await S({ satoshi: t2, currency: e2 })).toLocaleString(a2, { style: "currency", currency: e2 })) };
export {
  w as Invoice,
  D as LightningAddress,
  c as boostagrams,
  o as fetchWithL402,
  _ as fiat,
  i as l402,
  b as nostr,
  l as sendBoostagram
};
/*! Bundled license information:

@scure/base/lib/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=alby-tools.js.map
