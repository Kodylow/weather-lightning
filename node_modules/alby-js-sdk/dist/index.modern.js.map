{"version":3,"file":"index.modern.js","sources":["../src/utils.ts","../src/request.ts","../src/OAuth2User.ts","../src/OAuth2Bearer.ts","../src/types.ts","../src/webln/NostrWeblnProvider.ts","../src/helpers.ts","../src/client.ts","../src/webln/OauthWeblnProvider.ts"],"sourcesContent":["// https://stackoverflow.com/a/62969380\nexport function buildQueryString(query: Record<string, any>): string {\n  return Object.entries(query)\n    .map(([key, value]) =>\n      key && value\n        ? `${key}=${value}`\n        : \"\"\n    )\n    .join(\"&\");\n}\n\nexport function basicAuthHeader(client_id: string, client_secret: string | undefined) {\n  return `Basic ${btoa(`${client_id}:${client_secret}`)}`;\n}\n","import fetch from 'cross-fetch';\nimport { buildQueryString } from \"./utils\";\nimport {\n  AuthClient,\n} from \"./types\";\n\nconst BASE_URL = \"https://api.getalby.com\";\n\nexport interface RequestOptions extends Omit<RequestInit, \"body\"> {\n  auth?: AuthClient;\n  endpoint: string;\n  params?: Record<string, any>;\n  request_body?: Record<string, any>;\n  method?: string;\n  max_retries?: number;\n  base_url?: string;\n}\n\nasync function fetchWithRetries(\n  url: RequestInfo,\n  init: RequestInit,\n  max_retries = 0\n): Promise<Response> {\n  const res = await fetch(url, init);\n  if (res.status === 429 && max_retries > 0) {\n    const rateLimitReset = Number(res.headers.get(\"x-rate-limit-reset\"));\n    const rateLimitRemaining = Number(res.headers.get(\"x-rate-limit-remaining\"));\n    const timeTillReset = rateLimitReset * 1000 - Date.now();\n    let timeToWait = 1000;\n    if (rateLimitRemaining === 0)\n      timeToWait = timeTillReset;\n    await new Promise((resolve) => setTimeout(resolve, timeToWait));\n    return fetchWithRetries(url, init, max_retries - 1);\n  }\n  return res;\n}\n\nclass AlbyResponseError extends Error {\n  status: number;\n  statusText: string;\n  headers: Record<string, any>;\n  error: any; // todo: typeable?\n  constructor(\n    status: number,\n    statusText: string,\n    headers: Headers,\n    error: any\n  ) {\n    super();\n    this.status = status;\n    this.statusText = statusText;\n    this.headers = headers;\n    this.error = error;\n  }\n}\n\nexport async function request({\n  auth,\n  endpoint,\n  params: query = {},\n  request_body,\n  method,\n  max_retries,\n  base_url = BASE_URL,\n  headers,\n  ...options\n}: RequestOptions): Promise<Response> {\n  const url = new URL(base_url + endpoint);\n  url.search = buildQueryString(query);\n  const isPost = method === \"POST\" && !!request_body;\n  const authHeader = auth\n    ? await auth.getAuthHeader(url.href, method)\n    : undefined;\n  const response = await fetchWithRetries(\n    url.toString(),\n    {\n      headers: {\n        ...(isPost\n          ? { \"Content-Type\": \"application/json; charset=utf-8\" }\n          : undefined),\n        ...authHeader,\n        ...headers,\n      },\n      method,\n      body: isPost ? JSON.stringify(request_body) : undefined,\n      ...options,\n    },\n    max_retries\n  );\n  if (!response.ok) {\n    const error = await response.json();\n    throw new AlbyResponseError(\n      response.status,\n      response.statusText,\n      response.headers,\n      error\n    );\n  }\n  return response;\n}\n\nexport async function rest<T = any>(\n  args: RequestOptions\n): Promise<T> {\n  const response = await request(args);\n  return response.json() as any;\n}\n","import CryptoJS from 'crypto-js';\nimport { buildQueryString, basicAuthHeader } from \"./utils\";\nimport { OAuthClient, AuthHeader, GetTokenResponse, Token, GenerateAuthUrlOptions } from \"./types\";\nimport { RequestOptions, rest } from \"./request\";\n\nconst AUTHORIZE_URL = \"https://getalby.com/oauth\";\n\nexport type OAuth2Scopes =\n  | \"account:read\"\n  | \"invoices:create\"\n  | \"invoices:read\"\n  | \"transactions:read\"\n  | \"balance:read\"\n  | \"payments:send\";\n\nexport interface OAuth2UserOptions {\n  client_id: string;\n  client_secret?: string;\n  callback: string;\n  scopes: OAuth2Scopes[];\n  request_options?: Partial<RequestOptions>;\n  token?: Token;\n}\n\nfunction processTokenResponse(token: GetTokenResponse): Token {\n  const { expires_in, ...rest } = token;\n  return {\n    ...rest,\n    ...(!!expires_in && {\n      expires_at: Date.now() + expires_in * 1000,\n    }),\n  };\n}\n\nexport class OAuth2User implements OAuthClient {\n  token?: Token;\n  options: OAuth2UserOptions;\n  code_verifier?: string;\n  code_challenge?: string;\n  constructor(options: OAuth2UserOptions) {\n    const { token, ...defaultOptions } = options;\n    this.options = {client_secret: '', ...defaultOptions};\n    this.token = token;\n  }\n\n  /**\n   * Refresh the access token\n   */\n  async refreshAccessToken(): Promise<{ token: Token }> {\n    const refresh_token = this.token?.refresh_token;\n    const { client_id, client_secret, request_options } = this.options;\n    if (!client_id) {\n      throw new Error(\"client_id is required\");\n    }\n    if (!refresh_token) {\n      throw new Error(\"refresh_token is required\");\n    }\n    const data = await rest<GetTokenResponse>({\n      ...request_options,\n      endpoint: `/oauth/token`,\n      params: {\n        client_id,\n        grant_type: \"refresh_token\",\n        refresh_token,\n      },\n      method: \"POST\",\n      headers: {\n        ...request_options?.headers,\n        \"Content-type\": \"application/x-www-form-urlencoded\",\n        ...{\n          Authorization: basicAuthHeader(client_id, client_secret),\n        },\n      },\n    });\n    const token = processTokenResponse(data);\n    this.token = token;\n    return { token };\n  }\n\n  /**\n   * Check if an access token is expired\n   */\n  isAccessTokenExpired(): boolean {\n    const refresh_token = this.token?.refresh_token;\n    const expires_at = this.token?.expires_at;\n    if (!expires_at) return true;\n    return !!refresh_token && expires_at <= Date.now() + 1000;\n  }\n\n  /**\n   * Request an access token\n   */\n  async requestAccessToken(code?: string): Promise<{ token: Token }> {\n    const { client_id, client_secret, callback, request_options } =\n      this.options;\n    const code_verifier = this.code_verifier;\n    if (!client_id) {\n      throw new Error(\"client_id is required\");\n    }\n    if (!callback) {\n      throw new Error(\"callback is required\");\n    }\n    const params = {\n      code,\n      grant_type: \"authorization_code\",\n      code_verifier,\n      client_id,\n      redirect_uri: callback,\n    };\n    const data = await rest<GetTokenResponse>({\n      ...request_options,\n      endpoint: `/oauth/token`,\n      params,\n      method: \"POST\",\n      headers: {\n        ...request_options?.headers,\n        \"Content-Type\": \"application/x-www-form-urlencoded\",\n        ...{\n          Authorization: basicAuthHeader(client_id, client_secret),\n        },\n      },\n    });\n    const token = processTokenResponse(data);\n    this.token = token;\n    return { token };\n  }\n\n  generateAuthURL(options?: GenerateAuthUrlOptions): string {\n    if (!options) { options = {}; }\n    console.log(options);\n    const { client_id, callback, scopes } = this.options;\n    if (!callback) throw new Error(\"callback required\");\n    if (!scopes) throw new Error(\"scopes required\");\n    let code_challenge_method;\n    if (options.code_challenge_method === \"S256\") {\n      const code_verifier = CryptoJS.lib.WordArray.random(64);\n      this.code_verifier = code_verifier.toString();\n      this.code_challenge = CryptoJS.SHA256(this.code_verifier).toString(CryptoJS.enc.Base64).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=+$/, '')\n      code_challenge_method = \"S256\";\n    } else if (options.code_challenge_method === \"plain\" && options.code_challenge) {\n      this.code_challenge = options.code_challenge;\n      this.code_verifier = options.code_challenge;\n      code_challenge_method = \"plain\";\n    }\n    const code_challenge = this.code_challenge;\n    const url = new URL(AUTHORIZE_URL);\n    url.search = buildQueryString({\n      ...options,\n      client_id,\n      scope: scopes.join(\" \"),\n      response_type: \"code\",\n      redirect_uri: callback,\n      code_challenge_method,\n      code_challenge,\n    });\n    return url.toString();\n  }\n\n  async getAuthHeader(): Promise<AuthHeader> {\n    if (!this.token?.access_token) throw new Error(\"access_token is required\");\n    if (this.isAccessTokenExpired()) await this.refreshAccessToken();\n    return {\n      Authorization: `Bearer ${this.token.access_token}`,\n    };\n  }\n}\n","import { AuthClient, AuthHeader } from \"./types\";\n\nexport class OAuth2Bearer implements AuthClient {\n  private bearer_token: string;\n\n  constructor(bearer_token: string) {\n    this.bearer_token = bearer_token;\n  }\n\n  getAuthHeader(): AuthHeader {\n    return {\n      Authorization: `Bearer ${this.bearer_token}`,\n    };\n  }\n}\n","\nexport type SuccessStatus = 200 | 201;\nexport type ResponseType = \"application/json\";\n\nexport interface AuthHeader {\n  Authorization: string;\n}\n\nexport interface GetTokenResponse {\n  /** Allows an application to obtain a new access token without prompting the user via the refresh token flow. */\n  refresh_token?: string;\n  /** Access tokens are the token that applications use to make API requests on behalf of a user.  */\n  access_token?: string;\n  token_type?: string;\n  expires_in?: number;\n  /** Comma-separated list of scopes for the token  */\n  scope?: string;\n}\n\nexport interface Token extends Omit<GetTokenResponse, \"expires_in\"> {\n  /** Date that the access_token will expire at.  */\n  expires_at?: number;\n}\n\n\nexport type GenerateAuthUrlOptions =\n  | {\n      code_challenge_method?: string;\n      code_challenge?: string;\n    }\n  | {\n      /** A random string you provide to verify against CSRF attacks.  The length of this string can be up to 500 characters. */\n      state?: string;\n      /** Specifies the method you are using to make a request (S256 OR plain). */\n      code_challenge_method: \"S256\";\n    }\n  | {\n      /** A random string you provide to verify against CSRF attacks.  The length of this string can be up to 500 characters. */\n      state: string;\n      /** A PKCE parameter, a random secret for each request you make. */\n      code_challenge: string;\n      /** Specifies the method you are using to make a request (S256 OR plain). */\n      code_challenge_method?: \"plain\";\n    };\n\nexport abstract class OAuthClient implements AuthClient {\n  abstract token?: Token;\n  abstract generateAuthURL(options: GenerateAuthUrlOptions): string;\n  abstract requestAccessToken(code?: string): Promise<{ token: Token }>\n  abstract getAuthHeader(\n    url?: string,\n    method?: string\n  ): Promise<AuthHeader> | AuthHeader;\n}\n\nexport abstract class AuthClient {\n  abstract getAuthHeader(\n    url?: string,\n    method?: string\n  ): Promise<AuthHeader> | AuthHeader;\n}\n\n// https://stackoverflow.com/a/50375286\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => void\n  ? I\n  : never;\n\nexport type GetSuccess<T> = {\n  [K in SuccessStatus & keyof T]: GetContent<T[K]>;\n}[SuccessStatus & keyof T];\n\nexport type AlbyResponse<T> = UnionToIntersection<ExtractAlbyResponse<T>>;\n\nexport type GetContent<T> = \"content\" extends keyof T\n  ? ResponseType extends keyof T[\"content\"]\n    ? T[\"content\"][ResponseType]\n    : never\n  : never;\n\nexport type ExtractAlbyResponse<T> = \"responses\" extends keyof T\n  ? GetSuccess<T[\"responses\"]>\n  : never;\n\nexport type InvoiceRequestParams = {\n  description?: string,\n  description_hash?: string,\n  amount: number,\n}\n\nexport type KeysendRequestParams = {\n  amount: number,\n  destination: string,\n  memo?: string,\n  customRecords?: Record<string, string>\n}\n\nexport type SendPaymentRequestParams = {\n  invoice: string,\n  amount?: number,\n}\n\nexport type SendBoostagramRequestParams = {\n  recipient: {\n    address: string,\n    customKey?: string,\n    customValue?: string,\n  },\n  boostagram: unknown,\n  amount: number,\n}\n\n\nexport type SendToAlbyRequestParams = {\n  account: string;\n  amount: number;\n  memo?: string;\n}\n\n","import {\n  nip04,\n  relayInit,\n  signEvent,\n  getEventHash,\n  nip19,\n  generatePrivateKey,\n  getPublicKey,\n  Relay,\n  Event,\n  UnsignedEvent\n} from 'nostr-tools';\n\nconst NWCs: Record<string,NostrWebLNOptions> = {\n  alby: {\n    authorizationUrl: \"https://nwc.getalby.com/apps/new\",\n    relayUrl: \"wss://relay.getalby.com/v1\",\n    walletPubkey: '69effe7b49a6dd5cf525bd0905917a5005ffe480b58eeb8e861418cf3ae760d9'\n  }\n};\n\ninterface NostrWebLNOptions {\n  authorizationUrl?: string; // the URL to the NWC interface for the user to confirm the session\n  relayUrl: string;\n  walletPubkey: string;\n  secret?: string;\n};\n\nexport class NostrWebLNProvider {\n  relay: Relay;\n  relayUrl: string;\n  secret: string | undefined;\n  walletPubkey: string;\n  options: NostrWebLNOptions;\n  subscribers: Record<string, (payload: any) => void>;\n\n  static parseWalletConnectUrl(walletConnectUrl: string) {\n    walletConnectUrl = walletConnectUrl.replace('nostrwalletconnect://', 'http://').replace('nostr+walletconnect://', 'http://'); // makes it possible to parse with URL in the different environments (browser/node/...)\n    const url = new URL(walletConnectUrl);\n    const options = {} as NostrWebLNOptions;\n    options.walletPubkey = url.host;\n    const secret = url.searchParams.get('secret');\n    const relayUrl = url.searchParams.get('relay');\n    if (secret) {\n      options.secret = secret;\n    }\n    if (relayUrl) {\n      options.relayUrl = relayUrl;\n    }\n    return options;\n  }\n\n  static withNewSecret(options?: ConstructorParameters<typeof NostrWebLNProvider>[0]) {\n    options = options || {};\n    options.secret = generatePrivateKey();\n    return new NostrWebLNProvider(options);\n  }\n\n  constructor(options?: { providerName?: string, authorizationUrl?: string, relayUrl?: string, secret?: string, walletPubkey?: string, nostrWalletConnectUrl?: string }) {\n    if (options && options.nostrWalletConnectUrl) {\n      options = {\n        ...NostrWebLNProvider.parseWalletConnectUrl(options.nostrWalletConnectUrl), ...options\n      };\n    }\n    const providerOptions = NWCs[options?.providerName || 'alby'] as NostrWebLNOptions;\n    this.options = { ...providerOptions, ...(options || {}) } as NostrWebLNOptions;\n    this.relayUrl = this.options.relayUrl;\n    this.relay = relayInit(this.relayUrl);\n    if (this.options.secret) {\n      this.secret = (this.options.secret.toLowerCase().startsWith('nsec') ? nip19.decode(this.options.secret).data : this.options.secret) as string;\n    }\n    this.walletPubkey = (this.options.walletPubkey.toLowerCase().startsWith('npub') ? nip19.decode(this.options.walletPubkey).data : this.options.walletPubkey) as string;\n    this.subscribers = {};\n\n    // @ts-ignore\n    if(globalThis.WebSocket === undefined) {\n      console.error(\"WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments\");\n    }\n  }\n\n  on(name: string, callback: () => void) {\n    this.subscribers[name] = callback;\n  }\n\n  notify(name: string, payload?: any) {\n    const callback = this.subscribers[name];\n    if (callback) {\n      callback(payload);\n    }\n  }\n\n  getNostrWalletConnectUrl(includeSecret = true) {\n    let url = `nostr+walletconnect://${this.walletPubkey}?relay=${this.relayUrl}&pubkey=${this.publicKey}`;\n    if (includeSecret) {\n      url = `${url}&secret=${this.secret}`;\n    }\n    return url;\n  }\n\n  get nostrWalletConnectUrl() {\n    return this.getNostrWalletConnectUrl();\n  }\n\n  get connected() {\n    return this.relay.status === 1;\n  }\n\n  get publicKey() {\n    if (!this.secret) {\n      throw new Error(\"Missing secret key\");\n    }\n    return getPublicKey(this.secret);\n  }\n\n  signEvent(event: Event) {\n    if (!this.secret) {\n      throw new Error(\"Missing secret key\");\n    }\n    return signEvent(event, this.secret)\n  }\n\n  getEventHash(event: Event) {\n    return getEventHash(event);\n  }\n\n  async enable() {\n    if (this.connected) {\n      return Promise.resolve();\n    }\n    await this.relay.connect();\n  }\n\n  close() {\n    return this.relay.close();\n  }\n\n  async encrypt(pubkey: string, content: string) {\n    if (!this.secret) {\n      throw new Error('Missing secret');\n    }\n    const encrypted = await nip04.encrypt(this.secret, pubkey, content);\n    return encrypted;\n  }\n\n  async decrypt(pubkey: string, content: string) {\n    if (!this.secret) {\n      throw new Error('Missing secret');\n    }\n    const decrypted = await nip04.decrypt(this.secret, pubkey, content);\n    return decrypted;\n  }\n\n  // WebLN compatible response\n  // TODO: use NIP-47 get_info call\n  async getInfo() {\n    return {\n      methods: [\"getInfo\", \"sendPayment\"],\n      node: {},\n      supports: [\"lightning\"],\n      version: \"NWC\"\n    }\n  }\n\n  sendPayment(invoice: string) {\n    this.checkConnected();\n\n    return new Promise(async (resolve, reject) => {\n      const command = {\n        \"method\": \"pay_invoice\",\n        \"params\": {\n          \"invoice\": invoice\n        }\n      };\n      const encryptedCommand = await this.encrypt(this.walletPubkey, JSON.stringify(command));\n      let event: any = {\n        kind: 23194,\n        created_at: Math.floor(Date.now() / 1000),\n        tags: [['p', this.walletPubkey]],\n        content: encryptedCommand,\n      };\n\n      event.pubkey = this.publicKey;\n      event.id = this.getEventHash(event);\n      event.sig = this.signEvent(event);\n\n      // subscribe to NIP_47_SUCCESS_RESPONSE_KIND and NIP_47_ERROR_RESPONSE_KIND\n      // that reference the request event (NIP_47_REQUEST_KIND)\n      let sub = this.relay.sub([\n        {\n          kinds: [23195],\n          authors: [this.walletPubkey],\n          \"#e\": [event.id],\n        }\n      ]);\n\n      function replyTimeout() {\n        sub.unsub();\n        //console.error(`Reply timeout: event ${event.id} `);\n        reject(`reply timeout: event ${event.id}`);\n      }\n\n      let replyTimeoutCheck = setTimeout(replyTimeout, 60000);\n\n      sub.on('event', async (event) => {\n        //console.log(`Received reply event: `, event);\n        clearTimeout(replyTimeoutCheck);\n        sub.unsub();\n        const decryptedContent = await this.decrypt(this.walletPubkey, event.content);\n        let response;\n        try {\n          response = JSON.parse(decryptedContent);\n        } catch(e) {\n          reject({ error: \"invalid response\", code: \"INTERNAL\" });\n          return;\n        }\n        // @ts-ignore // event is still unknown in nostr-tools\n        if (event.kind == 23195 && response.result?.preimage) {\n          resolve({ preimage: response.result.preimage });\n          this.notify('sendPayment', event.content);\n        } else {\n          reject({ error: response.error?.message, code: response.error?.code });\n        }\n      });\n\n      let pub = this.relay.publish(event);\n\n      function publishTimeout() {\n        //console.error(`Publish timeout: event ${event.id}`);\n        reject({ error: `Publish timeout: event ${event.id}` });\n      }\n      let publishTimeoutCheck = setTimeout(publishTimeout, 5000);\n\n      pub.on('failed', (reason: unknown) => {\n        //console.debug(`failed to publish to ${this.relay.url}: ${reason}`)\n        clearTimeout(publishTimeoutCheck)\n        reject({ error: `Failed to publish request: ${reason}` });\n      });\n\n      pub.on('ok', () => {\n        //console.debug(`Event ${event.id} for ${invoice} published`);\n        clearTimeout(publishTimeoutCheck);\n      });\n    });\n  }\n\n  getAuthorizationUrl(options: { name?: string, returnTo?: string }) {\n    if (!this.options.authorizationUrl) {\n      throw new Error(\"Missing authorizationUrl option\");\n    }\n    const url = new URL(this.options.authorizationUrl);\n    if (options?.name) {\n      url.searchParams.set('c', options?.name);\n    }\n    url.searchParams.set('pubkey', this.publicKey);\n    if (options?.returnTo) {\n      url.searchParams.set('return_to', options.returnTo);\n    }\n    return url;\n  }\n\n  initNWC(options: { name?: string, returnTo?: string } = {}) {\n    // here we assume an browser context and window/document is available\n    // we set the location.host as a default name if none is given\n    if (!options.name) {\n      options.name = document.location.host;\n    }\n    const url = this.getAuthorizationUrl(options);\n    const height = 600;\n    const width = 400;\n    const top = window.outerHeight / 2 + window.screenY - height / 2;\n    const left = window.outerWidth / 2 + window.screenX - width / 2;\n\n    return new Promise((resolve, reject) => {\n      const popup = window.open(\n        url.toString(),\n        `${document.title} - Wallet Connect`,\n        `height=${height},width=${width},top=${top},left=${left}`\n      );\n      if (!popup) { reject(); return; } // only for TS?\n\n      const checkForPopup = () => {\n        if (popup && popup.closed) {\n          reject();\n          clearInterval(popupChecker);\n          window.removeEventListener('message', onMessage);\n        }\n      };\n\n      const onMessage = (message: { data: any, origin: string }) => {\n        const data = message.data;\n        if (data && data.type === 'nwc:success' && message.origin === `${url.protocol}//${url.host}`) {\n          resolve(data);\n          clearInterval(popupChecker);\n          window.removeEventListener('message', onMessage);\n          if (popup) {\n            popup.close(); // close the popup\n          }\n        }\n      };\n      const popupChecker = setInterval(checkForPopup, 500);\n      window.addEventListener('message', onMessage);\n    });\n  }\n\n  private checkConnected() {\n    if (!this.connected) {\n      throw new Error(\"please call enable() and await the promise before calling this function\")\n    }\n  }\n}\n\nexport const NWC = NostrWebLNProvider;\n","import {\n  SendBoostagramRequestParams,\n} from \"./types\";\n\n\nexport function keysendParamsFromBoostagram(boostagramParams: SendBoostagramRequestParams) {\n  const customRecords: Record<string, string> = {};\n  if (boostagramParams.recipient.customKey && boostagramParams.recipient.customValue) {\n    customRecords[boostagramParams.recipient.customKey] = boostagramParams.recipient.customValue;\n  }\n  // https://github.com/lightning/blips/blob/master/blip-0010.md\n  customRecords['7629169'] = JSON.stringify(boostagramParams.boostagram);\n\n  return {\n    destination: boostagramParams.recipient.address,\n    amount: boostagramParams.amount,\n    customRecords: customRecords,\n  };\n}","import { rest, RequestOptions } from \"./request\";\nimport {\n  AuthClient,\n  InvoiceRequestParams,\n  KeysendRequestParams,\n  SendPaymentRequestParams,\n  SendBoostagramRequestParams,\n  SendToAlbyRequestParams\n} from \"./types\";\nimport { keysendParamsFromBoostagram } from \"./helpers\";\nimport { OAuth2Bearer } from \"./auth\";\n\n\nexport class Client {\n  auth: AuthClient;\n  defaultRequestOptions?: Partial<RequestOptions>;\n\n  constructor(\n    auth: string | AuthClient,\n    requestOptions?: Partial<RequestOptions>\n  ) {\n    this.auth = typeof auth === \"string\" ? new OAuth2Bearer(auth) : auth;\n    this.defaultRequestOptions = {\n      ...requestOptions,\n      headers: {\n        \"User-Agent\": \"alby-js-api\",\n        ...requestOptions?.headers,\n      },\n    };\n  }\n\n  accountBalance(params: {}, request_options?: Partial<RequestOptions>) {\n    return rest({\n      auth: this.auth,\n      ...this.defaultRequestOptions,\n      ...request_options,\n      endpoint: `/balance`,\n      params,\n      method: \"GET\",\n    });\n  }\n\n  accountSummary(params: {}, request_options?: Partial<RequestOptions>) {\n    return rest({\n      auth: this.auth,\n      ...this.defaultRequestOptions,\n      ...request_options,\n      endpoint: `/user/summary`,\n      params,\n      method: \"GET\",\n    });\n  }\n\n  accountInformation(params: {}, request_options?: Partial<RequestOptions>) {\n    return rest({\n      auth: this.auth,\n      ...this.defaultRequestOptions,\n      ...request_options,\n      endpoint: `/user/me`,\n      params,\n      method: \"GET\",\n    });\n  }\n\n  accountValue4Value(params: {}, request_options?: Partial<RequestOptions>) {\n    return rest({\n      auth: this.auth,\n      ...this.defaultRequestOptions,\n      ...request_options,\n      endpoint: `/user/value4value`,\n      params,\n      method: \"GET\",\n    });\n  }\n\n  incomingInvoices(params: {}, request_options?: Partial<RequestOptions>) {\n    return rest({\n      auth: this.auth,\n      ...this.defaultRequestOptions,\n      ...request_options,\n      endpoint: `/invoices/incoming`,\n      params,\n      method: \"GET\",\n    });\n  }\n\n  outgoingInvoices(params: {}, request_options?: Partial<RequestOptions>) {\n    return rest({\n      auth: this.auth,\n      ...this.defaultRequestOptions,\n      ...request_options,\n      endpoint: `/invoices/outgoing`,\n      params,\n      method: \"GET\",\n    });\n  }\n\n  getInvoice(paymentHash: string, request_options?: Partial<RequestOptions>) {\n    return rest({\n      auth: this.auth,\n      ...this.defaultRequestOptions,\n      ...request_options,\n      endpoint: `/invoices/${paymentHash}`,\n      method: \"GET\",\n    });\n  }\n\n  createInvoice(invoice: InvoiceRequestParams, request_options?: Partial<RequestOptions>) {\n    return rest({\n      auth: this.auth,\n      ...this.defaultRequestOptions,\n      ...request_options,\n      endpoint: `/invoices`,\n      request_body: invoice,\n      method: \"POST\",\n    });\n  }\n\n  keysend(args: KeysendRequestParams | KeysendRequestParams[], request_options?: Partial<RequestOptions>) {\n    let endpoint, request_body;\n    if (Array.isArray(args)) {\n      endpoint = \"/payments/keysend/multi\";\n      request_body = { keysends: args };\n    } else {\n      endpoint = \"/payments/keysend\";\n      request_body = args;\n    }\n    return rest({\n      auth: this.auth,\n      ...this.defaultRequestOptions,\n      ...request_options,\n      endpoint,\n      request_body,\n      method: \"POST\",\n    });\n  }\n\n  sendPayment(params: SendPaymentRequestParams, request_options?: Partial<RequestOptions>) {\n    return rest({\n      auth: this.auth,\n      ...this.defaultRequestOptions,\n      ...request_options,\n      endpoint: `/payments/bolt11`,\n      request_body: params,\n      method: \"POST\",\n    });\n  }\n\n  sendBoostagram(args: SendBoostagramRequestParams | SendBoostagramRequestParams[], request_options?: Partial<RequestOptions>) {\n    let endpoint, request_body;\n    if (Array.isArray(args)) {\n      endpoint = \"/payments/keysend/multi\";\n      const keysends = args.map((b) => keysendParamsFromBoostagram(b));\n      request_body = { keysends };\n    } else {\n      endpoint = \"/payments/keysend\";\n      request_body = keysendParamsFromBoostagram(args);\n    }\n\n    return rest({\n      auth: this.auth,\n      ...this.defaultRequestOptions,\n      ...request_options,\n      endpoint,\n      request_body,\n      method: \"POST\",\n    });\n  }\n\n  sendToAlbyAccount(args: SendToAlbyRequestParams, request_options?: Partial<RequestOptions>) {\n    const params = {\n      destination: \"030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3\",\n      customRecords: {\n        \"696969\": args.account,\n      },\n      amount: args.amount,\n      memo: args.memo,\n    };\n    return rest({\n      auth: this.auth,\n      ...this.defaultRequestOptions,\n      ...request_options,\n      endpoint: `/payments/keysend`,\n      request_body: params,\n      method: \"POST\",\n    });\n  }\n\n\n}\n","import { Client } from '../client';\nimport {\n  OAuthClient,\n  KeysendRequestParams,\n} from \"../types\";\n\ninterface RequestInvoiceArgs {\n  amount: string | number;\n  defaultMemo?: string;\n}\n\nconst isBrowser = () => typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n\nexport class OauthWeblnProvider {\n  client: Client;\n  auth: OAuthClient;\n  oauth: boolean;\n  subscribers: Record<string, (payload: any) => void>;\n  isExecuting: boolean;\n\n  constructor(options: { auth: OAuthClient }) {\n    this.auth = options.auth;\n    this.client = new Client(options.auth);\n    this.oauth = true;\n    this.subscribers = {};\n    this.isExecuting = false;\n  }\n\n  on(name: string, callback: () => void) {\n    this.subscribers[name] = callback;\n  }\n\n  notify(name: string, payload?: any) {\n    const callback = this.subscribers[name];\n    if (callback) {\n      callback(payload);\n    }\n  }\n\n  async enable() {\n    if (this.isExecuting) { return; }\n    if (this.auth.token?.access_token) {\n      return { enabled: true };\n    }\n    if (isBrowser()) {\n      try {\n        this.isExecuting = true;\n        const result = await this.openAuthorization();\n      } finally {\n        this.isExecuting = false;\n      }\n    } else {\n      throw new Error(\"Missing access token\");\n    }\n  }\n\n  async sendPayment(invoice: string) {\n    if (this.isExecuting) { return; }\n    try {\n      this.isExecuting = true;\n      const result = await this.client.sendPayment({ invoice });\n      if (result.error) {\n        throw new Error(result.message);\n      }\n      this.notify('sendPayment', result);\n      return {\n        preimage: result.payment_preimage\n      }\n    } catch (error) {\n      let message = 'Unknown Error'\n      if (error instanceof Error) message = error.message\n      throw new Error(message);\n    } finally {\n      this.isExecuting = false;\n    }\n  }\n\n  async keysend(params: KeysendRequestParams) {\n    if (this.isExecuting) { return; }\n    try {\n      this.isExecuting = true;\n      const result = await this.client.keysend(params);\n      if (result.error) {\n        throw new Error(result.message);\n      }\n      this.notify('keysend', result);\n      return {\n        preimage: result.payment_preimage\n      }\n    } catch (error) {\n      let message = 'Unknown Error'\n      if (error instanceof Error) message = error.message\n      throw new Error(message);\n    } finally {\n      this.isExecuting = false;\n    }\n  }\n\n  async getInfo() {\n    return {\n      alias: \"Alby\"\n    };\n  }\n\n  async makeInvoice(params: RequestInvoiceArgs) {\n    if (this.isExecuting) { return; }\n    try {\n      this.isExecuting = true;\n      const result = await this.client.createInvoice({\n        amount: parseInt(params.amount.toString()),\n        description: params.defaultMemo\n      });\n      this.notify('makeInvoice', result);\n      return {\n        paymentRequest: result.payment_request\n      }\n    } catch (error) {\n      let message = 'Unknown Error'\n      if (error instanceof Error) message = error.message\n      throw new Error(message);\n    } finally {\n      this.isExecuting = false;\n    }\n  }\n\n  openAuthorization() {\n    const height = 700;\n    const width = 600;\n    const top = window.outerHeight / 2 + window.screenY - height / 2;\n    const left = window.outerWidth / 2 + window.screenX - width / 2;\n    const url = this.auth.generateAuthURL({ code_challenge_method: \"S256\" });\n\n    return new Promise((resolve, reject) => {\n      const popup = window.open(\n        url,\n        `${document.title} - WebLN enable`,\n        `height=${height},width=${width},top=${top},left=${left}`\n      );\n      let processingCode = false;\n      window.addEventListener('message', async (message) => {\n        const data = message.data;\n        if (data && data.type === 'alby:oauth:success' && message.origin === `${document.location.protocol}//${document.location.host}` && !processingCode) {\n          processingCode = true; // make sure we request the access token only once\n          console.info(\"Processing OAuth code response\");\n          const code = data.payload.code;\n          try {\n            await this.auth.requestAccessToken(code);\n            this.client = new Client(this.auth); // just to make sure we got a client with the correct auth and not the access token\n            if (popup) {\n              popup.close();\n            }\n            this.notify('enable');\n            resolve({ enabled: true });\n          } catch (e) {\n            console.error(e);\n            reject({ enabled: false });\n          }\n        }\n      });\n    });\n  }\n}\n"],"names":["buildQueryString","query","Object","entries","map","key","value","join","basicAuthHeader","client_id","client_secret","btoa","_excluded","BASE_URL","async","url","init","max_retries","res","status","Number","headers","get","rateLimitReset","Date","now","timeToWait","rateLimitRemaining","timeTillReset","Promise","resolve","setTimeout","fetchWithRetries","AlbyResponseError","Error","constructor","statusText","error","super","this","_ref","auth","endpoint","params","request_body","method","base_url","options","_objectWithoutPropertiesLoose","URL","search","authHeader","getAuthHeader","href","undefined","toString","_extends","isPost","body","JSON","stringify","response","ok","json","rest","args","request","_excluded2","processTokenResponse","token","expires_in","expires_at","OAuth2Bearer","bearer_token","Authorization","code_verifier","code_challenge","defaultOptions","_this$token","refresh_token","request_options","grant_type","isAccessTokenExpired","_this$token2","_this$token3","code","callback","redirect_uri","generateAuthURL","console","log","scopes","code_challenge_method","CryptoJS","lib","WordArray","random","SHA256","enc","Base64","replace","scope","response_type","_this$token4","access_token","refreshAccessToken","OAuthClient","alby","authorizationUrl","relayUrl","walletPubkey","static","walletConnectUrl","host","secret","searchParams","generatePrivateKey","NostrWebLNProvider","_options","relay","subscribers","nostrWalletConnectUrl","parseWalletConnectUrl","providerOptions","NWCs","providerName","relayInit","toLowerCase","startsWith","nip19","decode","data","globalThis","WebSocket","on","name","notify","payload","getNostrWalletConnectUrl","includeSecret","publicKey","connected","signEvent","event","getEventHash","connect","close","pubkey","content","nip04","encrypt","decrypt","methods","node","supports","version","sendPayment","invoice","_this","checkConnected","reject","command","kind","created_at","Math","floor","tags","encryptedCommand","id","sig","sub","kinds","authors","replyTimeoutCheck","unsub","_response$result","clearTimeout","parse","decryptedContent","e","result","preimage","_response$error","message","_response$error2","publish","publishTimeoutCheck","pub","reason","getAuthorizationUrl","set","returnTo","initNWC","document","location","top","window","outerHeight","screenY","height","outerWidth","screenX","width","popup","open","title","left","onMessage","type","origin","protocol","clearInterval","popupChecker","removeEventListener","setInterval","closed","addEventListener","NWC","keysendParamsFromBoostagram","boostagramParams","customRecords","recipient","customKey","customValue","boostagram","destination","address","amount","Client","requestOptions","defaultRequestOptions","accountBalance","accountSummary","accountInformation","accountValue4Value","incomingInvoices","outgoingInvoices","getInvoice","paymentHash","createInvoice","keysend","Array","isArray","keysends","sendBoostagram","b","sendToAlbyAccount","account","memo","client","oauth","isExecuting","_this$auth$token","enabled","openAuthorization","payment_preimage","alias","parseInt","description","defaultMemo","paymentRequest","payment_request","processingCode","info","requestAccessToken"],"mappings":"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"}